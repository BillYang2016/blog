<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bill Yang&#39;s Blog</title>
  
  <subtitle>路终会有尽头，但视野总能看到更远的地方。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.bill.moe/"/>
  <updated>2020-07-26T09:02:53.959Z</updated>
  <id>https://blog.bill.moe/</id>
  
  <author>
    <name>Bill Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020牛客暑期多校训练营（第二场）解题报告</title>
    <link href="https://blog.bill.moe/nowcoder-multischool-5/"/>
    <id>https://blog.bill.moe/nowcoder-multischool-5/</id>
    <published>2020-07-26T06:32:50.000Z</published>
    <updated>2020-07-26T09:02:53.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="A-Portal"><a href="#A-Portal" class="headerlink" title="A.Portal"></a>A.Portal</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are now in a big factory. The factory could be recognized as a graph with n vertices and m edges. Every edge has its length. You have k missions to do. The i-th mission is going to vertex $a_i$ , picking a block and then sending it to vertex $b_i$ . You should complete the missions in the order from 1-st to k-th. Initially you are standing at vectex 1.</p><p>You have a gun in your hand. When you are at some vertex u, you could shoot the gun at the ground, and then a portal will be built at vertex u. When there are two portals in the factory, assuming they are at u and v, you could transfer between u and v with no cost(just like an edge connecting u and v with length 0).</p><p>You also have a remote controller in your hand. It allows you to close a portal whenever you want and wherever you are(closing one portal at a time, not all portals at the same time). What’s more, there could be at most two existing portals. So if you want to create another portal when there exists two, you must use your controller to close one before you create.</p><p>You need to find the minimum distance you have to walk in order to complete all k missions.</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>第一眼看上去像一个np问题，然后再一想其实状态是可以被表示出来的。同时注意到性质：传送门只需要记录一个，因为另一个一定是你开始传送时脚下的结点。<br>于是状态可以被固定为$f(k,x)$，表示执行完第$k$个任务，传送门在$x$的最短路径。（其中当没有传送门的时候$x$为$0$，然后把每个任务拆分成两个任务）<br>考虑转移：（从$a$开始传送，传送到$b$，$x,y$是任务的起始点和终止点）</p><script type="math/tex; mode=display">f(i,a)=\min\{f(i-1,a)+dist(x,a)+dist(b,y)\}\quad\text{传送但不替换传送门}</script><script type="math/tex; mode=display">f(i,b)=\min\{f(i-1,a)+dist(x,a)+dist(b,y)\}\quad\text{传送且替换传送门}</script><script type="math/tex; mode=display">f(i,a)=\min\{f(i-1,b)+dist(x,a)+dist(a,y)\}\quad\text{不传送，在b留下传送门}</script><script type="math/tex; mode=display">f(i,a)=\min\{f(i-1,a)+dist(x,y)\}\quad\text{不传送也不留下传送门}</script><p>看上去似乎结束了（导致我们队多了3次罚时），但是还有一种情况：</p><script type="math/tex; mode=display">f(i,b)=\min\{f(i-1,a)+dist(a,b)+dist(b,y)\}\quad\text{从起点传送到a，在b留下传送门}</script><p>枚举$a,b$，时间复杂度$O(kn^2)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">305</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> n,m,k,a[maxn],b[maxn];</span><br><span class="line">LL Map[maxn][maxn],f[maxn&lt;&lt;<span class="number">1</span>][maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; mission;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">m=Get_Int();</span><br><span class="line">k=Get_Int();</span><br><span class="line"><span class="built_in">memset</span>(Map,<span class="number">0x0f</span>,<span class="keyword">sizeof</span>(Map));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)Map[i][i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),y=Get_Int();</span><br><span class="line">LL v=Get_Int();</span><br><span class="line">Map[x][y]=Map[y][x]=min(Map[x][y],v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)Map[i][j]=min(Map[i][j],Map[i][k]+Map[k][j]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++) &#123;</span><br><span class="line">a[i]=Get_Int();</span><br><span class="line">b[i]=Get_Int();</span><br><span class="line">&#125;</span><br><span class="line">mission.push_back(mp(<span class="number">1</span>,a[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++) &#123;</span><br><span class="line">mission.push_back(mp(a[i],b[i]));</span><br><span class="line"><span class="keyword">if</span>(i&lt;k)mission.push_back(mp(b[i],a[i+<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">k=mission.size();</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x0f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=mission[i<span class="number">-1</span>].first,y=mission[i<span class="number">-1</span>].second;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> now=<span class="number">0x0f0f0f0f0f0f0f0f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>; a&lt;=n; a++) &#123; <span class="comment">//从a开始传送</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">1</span>; b&lt;=n; b++) &#123; <span class="comment">//传送到b</span></span><br><span class="line">f[i][b]=min(f[i][b],f[i<span class="number">-1</span>][a]+Map[a][b]+Map[b][y]); <span class="comment">//起点传送到a，在b留下传送门</span></span><br><span class="line">f[i][a]=min(f[i][a],f[i<span class="number">-1</span>][b]+Map[x][a]+Map[b][y]); <span class="comment">//传送，不替换传送门</span></span><br><span class="line">f[i][b]=min(f[i][b],f[i<span class="number">-1</span>][b]+Map[x][a]+Map[b][y]); <span class="comment">//传送，替换传送门</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>; b&lt;=n; b++)f[i][a]=min(f[i][a],f[i<span class="number">-1</span>][b]+Map[x][a]+Map[a][y]); <span class="comment">//不传送，留下传送门</span></span><br><span class="line">f[i][a]=min(f[i][a],f[i<span class="number">-1</span>][a]+Map[x][y]); <span class="comment">//不传送，不留下传送门</span></span><br><span class="line">&#125;</span><br><span class="line">f[i][<span class="number">0</span>]=f[i<span class="number">-1</span>][<span class="number">0</span>]+Map[x][y]; <span class="comment">//没有传送门</span></span><br><span class="line">&#125;</span><br><span class="line">LL ans=LLONG_MAX/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)ans=min(ans,f[k][i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Graph"><a href="#B-Graph" class="headerlink" title="B.Graph"></a>B.Graph</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>Mr. W got a new graph with N vertices and N - 1 edges. It’s a connected graph without cycles. Each edge should have an ugly value. To make the graph more beautiful, Mr. W hope you can help him modify it. You can delete or add one edge with an ugly value at a time and you can do it as many times as you want. But the following conditions should be satisfied at any time:</p><ol><li>The graph is connected.</li><li>For each cycles in the graph, the XOR sum of all ugly values in the cycle is 0.</li></ol><p>Mr. W wants to know the minimum sum of ugly values of all edges in the graph.</p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>套路题，考虑最小异或生成树，完全图每条边$(x,y)$边权为$d[x]\oplus d[y]$，这道题答案就是最小异或生成树的边权和。<br>那么如何用题目给出的边权求出$d[i]$呢？  </p><ol><li>求异或方程组</li><li>$d[i]=i$到根的距离</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> _=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[_],ch[_*<span class="number">30</span>][<span class="number">2</span>],siz[_*<span class="number">30</span>],cnt,col,rt[_*<span class="number">30</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; g[_];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dsr[_*<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">29</span>;i&gt;=<span class="number">0</span>;--i) &#123;</span><br><span class="line"><span class="keyword">bool</span> k=x&amp;(<span class="number">1L</span>L&lt;&lt;i);</span><br><span class="line">siz[p]++;</span><br><span class="line"><span class="keyword">if</span>(!ch[p][k]) ch[p][k]=++cnt;</span><br><span class="line">p=ch[p][k];</span><br><span class="line">&#125; siz[p]++;</span><br><span class="line"><span class="keyword">if</span>(!rt[p]) rt[p]=++col;</span><br><span class="line">dsr[rt[p]].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> init,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=rt,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=init;i&gt;=<span class="number">0</span>;--i) &#123;</span><br><span class="line"><span class="keyword">bool</span> k=x&amp;(<span class="number">1L</span>L&lt;&lt;i);</span><br><span class="line"><span class="keyword">if</span>(ch[p][k]) p=ch[p][k];</span><br><span class="line"><span class="keyword">else</span> p=ch[p][!k],ans|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!ch[p][<span class="number">0</span>]&amp;&amp;!ch[p][<span class="number">1</span>]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(!ch[p][<span class="number">0</span>]||!ch[p][<span class="number">1</span>]) &#123;</span><br><span class="line">dfs(ch[p][<span class="number">0</span>]|ch[p][<span class="number">1</span>],dep<span class="number">-1</span>);</span><br><span class="line">rt[p]=rt[ch[p][<span class="number">0</span>]|ch[p][<span class="number">1</span>]];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> k=siz[ch[p][<span class="number">0</span>]]&lt;siz[ch[p][<span class="number">1</span>]];</span><br><span class="line">dfs(ch[p][<span class="number">0</span>],dep<span class="number">-1</span>),dfs(ch[p][<span class="number">1</span>],dep<span class="number">-1</span>);</span><br><span class="line">rt[p]=rt[ch[p][k]];</span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> nb=ch[p][!k];</span><br><span class="line">ch[p][!k]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:dsr[rt[nb]]) &#123;</span><br><span class="line">tmp=min(tmp,query(p,dep,x));</span><br><span class="line">dsr[rt[p]].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">ans+=tmp;</span><br><span class="line">ch[p][!k]=nb;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:g[u])&#123;</span><br><span class="line"><span class="keyword">int</span> w=x.second,v=x.first;</span><br><span class="line"><span class="keyword">if</span>(v^fa)&#123;</span><br><span class="line">a[v]=a[u]^w;DFS(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen("a.in","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u=read(),v=read(),x=read();</span><br><span class="line">u++;v++;</span><br><span class="line">g[u].push_back(make_pair(v,x));</span><br><span class="line">g[v].push_back(make_pair(u,x));</span><br><span class="line">&#125;</span><br><span class="line">DFS(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) insert(a[i]);</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">29</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Eazy"><a href="#C-Eazy" class="headerlink" title="C.Eazy"></a>C.Eazy</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>Mr. W is writing sequences. If he writes two positive integer sequences A and B with length K which satify $\sum_{i = 1}^{K} a_i = N ,\ \ \ \sum_{i = 1}^{K} b_i = M$, he will get $P = \prod_{i=1}^K min(a_i, b_i)$ points.<br>You want to know the sum of total points he can get in all possible sequences he can write.</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>比赛时没想出来<br>这是一道生成函数题，考虑生成函数$g(x,y)=\sum\min(i,j)x^iy^j$<br>将生成函数表示为：</p><script type="math/tex; mode=display">\begin{aligned}g(x,y)&=\sum\min(i,j)x^iy^j \\&=\sum_{k}kx^k\sum_{j\ge k}y^j+\sum_{k}ky^k\sum_{j\gt k}x^j \\&=\sum_{k}kx^k\frac{y^k}{1-y}+\sum_{k}ky^k\frac{x^{k+1}}{1-x} \\&=\sum_{k}kx^ky^k(\frac{1}{1-y}+\frac{x}{1-x})\end{aligned}</script><p>考虑生成函数$h(xy)=\sum_{k}kx^ky^k$</p><script type="math/tex; mode=display">\begin{aligned}h(xy)&=\sum_{k}kx^ky^k \\xyh(xy)&=\sum_{k}kx^{k+1}y^{k+1} \\(1-xy)h(xy)&=\sum_{k}x^ky^k=\frac{xy}{1-xy}\end{aligned}</script><p>故$h(xy)=\frac{xy}{(1-xy)^2}$<br>所以</p><script type="math/tex; mode=display">\begin{aligned}g(x,y)&=\frac{xy}{(1-xy)^2}(\frac{1}{1-y}+\frac{x}{1-x}) \\&=\frac{xy}{(1-xy)^2}\frac{1-x+x-xy}{(1-y)(1-x)} \\&=\frac{xy}{(1-xy)(1-x)(1-y)}\end{aligned}</script><p>现在我们得到了$n=m=k=1$的时候的答案，也就是$g(x,y)$中$x^ny^m$的系数</p><p>根据生成函数的卷积，$k&gt;1$的时候，答案就是</p><script type="math/tex; mode=display">g(x,y)^k=\frac{(xy)^k}{(1-xy)^k}\frac1{(1-x)^k}\frac1{(1-y)^k}</script><p>根据广义二项式定理有</p><script type="math/tex; mode=display">\frac{1}{(1-xy)^k}=\sum_{i=0}^\infty\begin{pmatrix}i+k-1 \\ k-1\end{pmatrix}x^iy^i</script><p>故</p><script type="math/tex; mode=display">\frac{(xy)^k}{(1-xy)^k}=\sum_{i=0}^\infty\begin{pmatrix}i+k-1 \\ k-1\end{pmatrix}x^{i+k}y^{i+k}</script><p>考虑枚举$j=i+k$，可以得到$h(xy)$的系数，还剩下$x^{n-j}$的系数由$f(x)=\frac{1}{1-x}$提供，剩下$y^{m-j}$的系数由$f(y)=\frac{1}{1-y}$提供。故枚举一次$j$即可，时间复杂度$O(n)$</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">LL fac[maxn],invf[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Quick_Pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">LL sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>,a=a*a%mod)<span class="keyword">if</span>(b&amp;<span class="number">1</span>)sum=sum*a%mod;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> Quick_Pow(x,mod<span class="number">-2</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;<span class="keyword">return</span> fac[n]*invf[m]%mod*invf[n-m]%mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;maxn; i++)fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">invf[maxn<span class="number">-1</span>]=inv(fac[maxn<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=maxn<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)invf[i]=invf[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line"><span class="keyword">int</span> t=Get_Int();</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="keyword">int</span> n=Get_Int(),m=Get_Int(),k=Get_Int();</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&lt;=min(n,m); i++)ans=(ans+C(i<span class="number">-1</span>,k<span class="number">-1</span>)*C(n-i+k<span class="number">-1</span>,k<span class="number">-1</span>)%mod*C(m-i+k<span class="number">-1</span>,k<span class="number">-1</span>)%mod)%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Drop-Voicing"><a href="#D-Drop-Voicing" class="headerlink" title="D.Drop Voicing"></a>D.Drop Voicing</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>Inaka composes music. Today’s arrangement includes a chord of nn notes that are pairwise distinct, represented by a permutation $p_{1 \dots n}$ of integers from $1$ to $n$ (inclusive) denoting the notes from the lowest to the highest.</p><p>Her friend, Miyako, sneaks in and plays a trick by altering the chord with the following two operations:</p><ul><li>Drop-2: Take out the second highest note and move it to the lowest position, i.e. change the permutation to $p_{n-1}, p_1, p_2, \dots, p_{n-3}, p_{n-2}, p_n$.</li><li>Invert: Take out the lowest note and move it to the highest position, i.e. change the permutation to $p_2, p_3, \dots, p_{n-1}, p_n, p_1$.</li></ul><p>Any number of consecutive Drop-2 operations is considered a multi-drop. Miyako would like to change the permutation to an ordered permutation, $1, 2, \dots, n$,in the fewest number of multi-drops possible. Please help her find the number of multi-drops needed.</p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>将序列变成一个环，两个连续的操作等价于：</p><ul><li>将最后一个数插入到另一个位置</li><li>旋转序列构成的环</li></ul><p>因为只计算第一种操作的数量，故再次等价于：</p><ul><li>将某一个数插入到另一个位置</li></ul><p>先用$O(n)$枚举旋转次数，通过若干次插入使得原序列有序，最少的次数就是$n-LIS$<br>$O(n^2\log n)$即可解决问题，也可以$O(n^3)$或者$O(n^2)$解决问题（留给读者思考，滑稽）。  </p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">505</span>];<span class="comment">//对应的数是否已经放了</span></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; s[tail]) &#123;</span><br><span class="line">            s[++tail] = a[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = upper_bound(s,s+tail,a[i]) - s;</span><br><span class="line">        s[p] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;=n;j++) tmp.push_back(arr[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++) tmp.push_back(arr[j]);</span><br><span class="line">        ans = min(ans,n-LIS(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Drop-Voicing-1"><a href="#D-Drop-Voicing-1" class="headerlink" title="D.Drop Voicing"></a>D.Drop Voicing</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定置换，求有多少排列可以通过这个置换变成顺序</p><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>求所有环的lcm即可，需要高精度<br>最终答案只有几百位<br>怕超时可以统计质数个数然后启发式合并</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> vst,cnt,a</span><br><span class="line">    <span class="comment">#vst[x] = True</span></span><br><span class="line">    <span class="comment">#Size[cnt] += 1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">not</span> vst[x]):</span><br><span class="line">        vst[x] = <span class="keyword">True</span></span><br><span class="line">        Size[cnt] += <span class="number">1</span></span><br><span class="line">        x = a[x]</span><br><span class="line">    <span class="comment">#if (not vst[a[x]]):</span></span><br><span class="line">    <span class="comment">#   dfs(a[x])</span></span><br><span class="line">n = int(input())</span><br><span class="line">a = [int(<span class="number">0</span>)] + list(map(int,input().split()))</span><br><span class="line">Size = [int(<span class="number">0</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">vst = [<span class="keyword">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">cnt = int(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#线性筛 begin</span></span><br><span class="line">pri_pre = [int(<span class="number">0</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">primes = []</span><br><span class="line">pri = [int(<span class="number">0</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">pri[<span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pri[i]:</span><br><span class="line">        primes.append(i)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> primes:</span><br><span class="line">        <span class="keyword">if</span> i * p &gt; n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        pri[i*p] = <span class="keyword">True</span></span><br><span class="line">        pri_pre[i*p] = p</span><br><span class="line">        <span class="keyword">if</span> i % p == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment">#线性筛 end</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> vst[i]):</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        dfs(i)</span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,cnt+<span class="number">1</span>):</span><br><span class="line">    cur = Size[i]</span><br><span class="line">    cur_cnt = Counter()</span><br><span class="line">    <span class="keyword">while</span> (pri_pre[cur] != <span class="number">0</span>):</span><br><span class="line">        cur_cnt[pri_pre[cur]] += <span class="number">1</span></span><br><span class="line">        cur //= pri_pre[cur]</span><br><span class="line">    <span class="keyword">if</span> cur &gt; <span class="number">1</span>:</span><br><span class="line">        cur_cnt[cur] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (len(cur_cnt)):</span><br><span class="line">        ans.append(cur_cnt)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(y) - len(x)</span><br><span class="line">ans = sorted(ans,key=functools.cmp_to_key(cmp))</span><br><span class="line">merge_ans = Counter()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> ans:</span><br><span class="line">    merge_ans |= x</span><br><span class="line">result = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> p,pp <span class="keyword">in</span> merge_ans.items():</span><br><span class="line">    result *= p ** pp</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h2 id="F-DPS"><a href="#F-DPS" class="headerlink" title="F.DPS"></a>F.DPS</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>When you are playing multiplayer games, you may want to show that you are the MVP of your team — or blame the one always wandering and watching away from the storm center. Well, there’re statistics that show you preformance, but sometimes numbers speak softer than charts. Now, you’re hired to write a program that output ASCII art histograms showing damage dealt to enemies.<br>There are n players in the game. Given that the i-th player dealt $d_i$ damage to enemies where $\max_i d_i &gt; 0$ is granted, you need to calculate the number $s_i$ of spaces in the bar by the following foluma:<br>$s_i = \lceil 50 \frac {d_i} {\max_i d_i} \rceil$<br>Instead of formal definition of bar description, we will give an example. For some player i whose $s_i = 7$ and $d_i = 777$, the bar is shown as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------+</span><br><span class="line">|       |777</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure></p><p>Moreover, you have to mark the player with maximal damage dealt to enemies by replacing the last space into ‘*’. If there’re multiple maximum, mark all of them.<br>See samples for more ideas.</p><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>签到题</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> Max=<span class="number">0</span>;</span><br><span class="line">n=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">d[i]=Get_Int();</span><br><span class="line">Max=max(Max,d[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="built_in">ceil</span>(<span class="number">50.0</span>*d[i]/Max);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'+'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=s; i++)<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'+'</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'|'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s; i++)<span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">if</span>(d[i]==Max) &#123;</span><br><span class="line"><span class="keyword">if</span>(s)<span class="built_in">putchar</span>(<span class="string">'*'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(s) <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'|'</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[i]);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'+'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=s; i++)<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'+'</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Interval"><a href="#H-Interval" class="headerlink" title="H.Interval"></a>H.Interval</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>Mr. W have a sequence A with length N.<br>$F(l,r) = A_l\&amp;A_{l+1}\&amp;…\&amp;A_r$<br>Set $S(l,r) = \{ F(a,b)\ | min(l, r)\leq a \leq b \leq max(l, r) \}$<br>Mr.W makes Q queries. For each query he wants to know the size of S(L,R) for given L, R.<br>L, R will not be given directly. He will give you L’ and R’.<br>$L = (L’ \oplus lastans) \% N + 1$<br>$R = (R’ \oplus lastans) \% N + 1$<br>$\oplus$ means XOR.<br>Lastans donates the answer of last query. It’s zero at the beginning.</p><h3 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h3><p>固定$r$，考虑不同的$F(l,r)$最多只有$30n$个<br>使用map把这些不同的$F(l,r)$全部找出来，相同的保留$l$最大的<br>这些区间对比他大的区间都有$1$的贡献<br>接下来就是一个二维偏序问题，可以使用主席树处理</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxt=<span class="number">20000005</span>,maxn=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">President_Tree</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> lson,rson,val;</span><br><span class="line">Tree(<span class="keyword">int</span> l=<span class="number">0</span>,<span class="keyword">int</span> r=<span class="number">0</span>,<span class="keyword">int</span> v=<span class="number">0</span>):lson(l),rson(r),val(v) &#123;&#125;</span><br><span class="line">&#125; tree[maxt];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls tree[index].lson</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs tree[index].rson</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((Left+Right)&gt;&gt;1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;index,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">tree[++cnt]=tree[index];</span><br><span class="line">index=cnt;</span><br><span class="line">tree[index].val+=val;</span><br><span class="line"><span class="keyword">if</span>(Left==Right)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid)update(ls,Left,mid,pos,val);</span><br><span class="line"><span class="keyword">else</span> update(rs,mid+<span class="number">1</span>,Right,pos,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Left&gt;right||Right&lt;left)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(left&lt;=Left&amp;&amp;right&gt;=Right)<span class="keyword">return</span> tree[index].val;</span><br><span class="line"><span class="keyword">return</span> query(ls,Left,mid,left,right)+query(rs,mid+<span class="number">1</span>,Right,left,right);</span><br><span class="line">&#125;</span><br><span class="line">&#125; pt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,root[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; last,Max;</span><br><span class="line">n=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; now;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int();</span><br><span class="line">now[x]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p:last)now[p.first&amp;x]=max(now[p.first&amp;x],p.second);</span><br><span class="line">root[i]=root[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p:now) &#123;</span><br><span class="line"><span class="keyword">if</span>(Max.count(p.first))pt.update(root[i],<span class="number">1</span>,n,Max[p.first],<span class="number">-1</span>);</span><br><span class="line">Max[p.first]=p.second;</span><br><span class="line">pt.update(root[i],<span class="number">1</span>,n,p.second,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">last=now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q=Get_Int(),lastans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(q--) &#123;</span><br><span class="line"><span class="keyword">int</span> l=(Get_Int()^lastans)%n+<span class="number">1</span>,r=(Get_Int()^lastans)%n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r)swap(l,r);</span><br><span class="line">lastans=pt.query(root[r],<span class="number">1</span>,n,l,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lastans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-Interval"><a href="#I-Interval" class="headerlink" title="I.Interval"></a>I.Interval</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个无穷大的二维网格，每个格子可以是1、2或者3，每个1旁边要有一个2和3，要使1的占比最大，求最大占比：$\lim_{n\to\infty} \lim_{m\to\infty} \frac{f(n,m)}{n\cdot m}$。</p><h3 id="题目分析-7"><a href="#题目分析-7" class="headerlink" title="题目分析"></a>题目分析</h3><p>对于每一个点$(x,y)$，若$(x+y)\bmod3\neq0$，其上下左右必定有且仅有两个点$(x+dx,y+dy)$他们的$(x+dx+y+dy)\bmod3=0$，使它们其中有一个是$2$，有一个是$3$，那么所有$(x+y)\bmod3\neq0$的点都可以填$1$。（交错填$2,3$即可）<br>因为所有$2,3$不相邻，且每个$1$旁边有且仅有一个$2,3$，故这样的方案是合法的且是上界，故答案即为$\frac23$。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"0.666667"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="ACM" scheme="https://blog.bill.moe/categories/ACM/"/>
    
    
      <category term="动态规划" scheme="https://blog.bill.moe/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="异或" scheme="https://blog.bill.moe/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="数学" scheme="https://blog.bill.moe/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="生成函数" scheme="https://blog.bill.moe/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="数论" scheme="https://blog.bill.moe/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="比赛酱油记" scheme="https://blog.bill.moe/tags/%E6%AF%94%E8%B5%9B%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
      <category term="主席树" scheme="https://blog.bill.moe/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>2020牛客暑期多校训练营（第二场）解题报告</title>
    <link href="https://blog.bill.moe/nowcoder-multischool-2/"/>
    <id>https://blog.bill.moe/nowcoder-multischool-2/</id>
    <published>2020-07-17T05:06:28.000Z</published>
    <updated>2020-07-26T06:38:14.167Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天A了5题，还算不错，但是AK的队伍好像有点多啊（</p><a id="more"></a><h2 id="B-Boundary"><a href="#B-Boundary" class="headerlink" title="B.Boundary"></a>B.Boundary</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given ${n}$ points in 2D plane. Considering all circles that the origin point ${(0, 0)}$ is on their boundries, find the one with the maximum given points on its boundry. Print the maximum number of points.</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这道题首先可以想到使用$O(n^2)$的时间代价枚举圆（计算三点成圆的时间是$O(1)$的）<br>但是我们似乎只能用$O(n)$的时间去枚举圆上的点。  </p><p>与题解不同的是，我们可以想到用map做所有圆的hash，自定义类记录下圆心和半径，重载一下小于符号即可。<br>但是map的常数过大，于是改成排序指针即可。  </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"avx,avx2,fma"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-3</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line">Point(<span class="keyword">double</span> _x=<span class="number">0</span>,<span class="keyword">double</span> _y=<span class="number">0</span>):x(_x),y(_y) &#123;&#125;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">tcircle</span><span class="params">(Point pt1, Point pt2, Point pt3, <span class="keyword">double</span> &amp;radius)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> x1 = pt1.x, x2 = pt2.x, x3 = pt3.x;</span><br><span class="line"><span class="keyword">double</span> y1 = pt1.y, y2 = pt2.y, y3 = pt3.y;</span><br><span class="line"><span class="keyword">double</span> a = x1 - x2;</span><br><span class="line"><span class="keyword">double</span> b = y1 - y2;</span><br><span class="line"><span class="keyword">double</span> c = x1 - x3;</span><br><span class="line"><span class="keyword">double</span> d = y1 - y3;</span><br><span class="line"><span class="keyword">double</span> e = ((x1 * x1 - x2 * x2) + (y1 * y1 - y2 * y2)) / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">double</span> f = ((x1 * x1 - x3 * x3) + (y1 * y1 - y3 * y3)) / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">double</span> det = b * c - a * d;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">fabs</span>(det) &lt; eps) &#123;</span><br><span class="line">radius = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> Point(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> x0 = -(d * e - b * f) / det;</span><br><span class="line"><span class="keyword">double</span> y0 = -(a * f - c * e) / det;</span><br><span class="line">radius = hypot(x1 - x0, y1 - y0);</span><br><span class="line"><span class="keyword">return</span> Point(x0, y0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(x-y)&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> x&lt;y?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y,r;</span><br><span class="line">node(<span class="keyword">double</span> _x=<span class="number">0</span>,<span class="keyword">double</span> _y=<span class="number">0</span>,<span class="keyword">double</span> _r=<span class="number">0</span>):x(_x),y(_y),r(_r) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(r-b.r) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(x-b.x) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(y-b.y) &lt; eps) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//equal</span></span><br><span class="line"><span class="keyword">return</span> dcmp(r,b.r)&lt;<span class="number">0</span>||(dcmp(r,b.r)==<span class="number">0</span>&amp;&amp;dcmp(x,b.x)&lt;<span class="number">0</span>)||(dcmp(r,b.r)==<span class="number">0</span>&amp;&amp;dcmp(x,b.x)==<span class="number">0</span>&amp;&amp;dcmp(y,b.y)&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map&lt;node,int&gt; M;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">node mem[<span class="number">4000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> memcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line"><span class="keyword">double</span> r=<span class="number">0</span>;</span><br><span class="line">Point tmp=tcircle(a[i],a[j],Point(<span class="number">0</span>,<span class="number">0</span>),r);</span><br><span class="line"><span class="keyword">if</span>(r==<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">node tmpp=node(tmp.x,tmp.y,r);</span><br><span class="line">mem[memcnt++] = tmpp;</span><br><span class="line"><span class="comment">//M[tmpp]++;</span></span><br><span class="line">&#125;</span><br><span class="line">sort(mem,mem+memcnt);</span><br><span class="line"><span class="keyword">int</span> curcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">node x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;memcnt;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">curcnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">bool</span> eq = !(mem[i] &lt; mem[i<span class="number">-1</span>]) &amp;&amp; !(mem[i<span class="number">-1</span>] &lt; mem[i]);</span><br><span class="line"><span class="keyword">if</span> (eq) &#123;</span><br><span class="line">curcnt ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (curcnt &gt; ans) &#123;</span><br><span class="line">ans = curcnt;</span><br><span class="line">x = mem[st];</span><br><span class="line">&#125;</span><br><span class="line">curcnt = <span class="number">1</span>;</span><br><span class="line">st = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (curcnt &gt; ans) &#123;</span><br><span class="line">ans = curcnt;</span><br><span class="line">x = mem[st];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="keyword">if</span>(dcmp((a[i].x-x.x)*(a[i].x-x.x)+(a[i].y-x.y)*(a[i].y-x.y),x.r*x.r)==<span class="number">0</span>)cnt++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Cover-the-Tree"><a href="#C-Cover-the-Tree" class="headerlink" title="C.Cover the Tree"></a>C.Cover the Tree</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an unrooted tree, you should choose the minimum number of chains that all edges in the tree are covered by at least one chain. Print the minimum number and one solution. If there are multiple solutions, print any of them.</p><h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>根据结论答案是$\lceil\frac n2\rceil$，但是题目要我们输出方案。<br>这里采取了和题解不同的方法。  </p><p>我们从叶子结点开始处理，在每个结点处做向上传递叶子结点的操作：  </p><ul><li>若本结点有奇数个子结点，随便留下一个子结点所对应的叶子结点向上传递，剩下的结点两两匹配</li><li>若本结点有偶数个子结点，随便留下两个子结点所对应的叶子结点向上传递，剩下的结点两两匹配</li></ul><p><strong>注意，向上传递的结点尽量保证不来自同一子结点，同时匹配的时候也不能匹配来自同一子结点的两个结点</strong></p><p>最终在根结点时把剩下的结点两两匹配完（如果剩下了一个结点，该结点与根结点匹配）<br>为了保证处理时不会匹配来自同一子结点的两个结点，我们边匹配边加入队列，在判断时优先匹配后加入队列，同时挑选一个度数大于1的根节点即可。  </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">pii <span class="title">TreeDp</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(edges[Now].size()==<span class="number">1</span>&amp;&amp;fa!=<span class="number">-1</span>)<span class="keyword">return</span> mp(Now,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">if</span>(Next==fa)<span class="keyword">continue</span>;</span><br><span class="line">pii tmpp=TreeDp(Next,Now);</span><br><span class="line"><span class="keyword">if</span>(tmp.size()&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">ans.push_back(mp(tmp.back(),tmpp.first));</span><br><span class="line">tmp.pop_back();</span><br><span class="line">&#125; <span class="keyword">else</span> tmp.push_back(tmpp.first);</span><br><span class="line"><span class="keyword">if</span>(tmp.size()&gt;=<span class="number">2</span>&amp;&amp;tmpp.second!=<span class="number">-1</span>) &#123;</span><br><span class="line">swap(tmp.back(),tmp[<span class="number">0</span>]);</span><br><span class="line">ans.push_back(mp(tmp.back(),tmpp.second));</span><br><span class="line">tmp.pop_back();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmp.size()&lt;<span class="number">2</span>&amp;&amp;tmpp.second!=<span class="number">-1</span>)tmp.push_back(tmpp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fa==<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(tmp.size()==<span class="number">2</span>)ans.push_back(mp(tmp[<span class="number">0</span>],tmp[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">else</span> ans.push_back(mp(tmp[<span class="number">0</span>],Now));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tmp.size()==<span class="number">2</span>)<span class="keyword">return</span> mp(tmp[<span class="number">0</span>],tmp[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mp(tmp[<span class="number">0</span>],<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n%d %d\n"</span>,x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">edges[x].push_back(y);</span><br><span class="line">edges[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="keyword">if</span>(edges[i].size()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">TreeDp(i,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans.size());</span><br><span class="line"><span class="keyword">for</span>(pii x:ans)<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,x.first,x.second);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Duration"><a href="#D-Duration" class="headerlink" title="D.Duration"></a>D.Duration</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given two moments on the same day in the form of <strong>HH:MM:SS</strong>, print the number of seconds between the two moments.</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>签到题</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (!(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)) c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">res = res*<span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h = read();</span><br><span class="line"><span class="keyword">int</span> m = read();</span><br><span class="line"><span class="keyword">int</span> s = read();</span><br><span class="line">m += h * <span class="number">60</span>;</span><br><span class="line">s += m * <span class="number">60</span>;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">abs</span>(gettime() - gettime()));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Fake-Maxpooling"><a href="#F-Fake-Maxpooling" class="headerlink" title="F.Fake Maxpooling"></a>F.Fake Maxpooling</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a matrix of size $n\times m$ and an integer ${k}$, where $A_{i,j} = lcm(i, j)$, the least common multiple of ${i}$ and ${j}$. You should determine the sum of the maximums among all $k\times k$ submatrices.</p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>预处理矩阵，两次滑动窗口即可。<br>如果$\gcd$写成线性时间复杂度的话，最终时间就是$O(nm)$。<br>不过带$\log$也过了</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t[N][N];</span><br><span class="line"><span class="keyword">int</span> ans[N][N];</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; win(N);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准的滑动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> len, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *ans)</span> </span>&#123;</span><br><span class="line">win.clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line"><span class="keyword">while</span>(!win.empty() &amp;&amp; arr[win.back()] &lt; arr[i])</span><br><span class="line">win.pop_back();</span><br><span class="line"><span class="keyword">while</span>(!win.empty() &amp;&amp; win.front() &lt; i - len + <span class="number">1</span>)</span><br><span class="line">win.pop_front();</span><br><span class="line">win.push_back(i);</span><br><span class="line"><span class="keyword">if</span>(i + <span class="number">1</span> &gt;= len)</span><br><span class="line">ans[i - len + <span class="number">1</span>] = arr[win.front()];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> m, n, a, b, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">a=k;b=k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">t[i][j]=(i+<span class="number">1</span>)/__gcd(i+<span class="number">1</span>,j+<span class="number">1</span>)*(j+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">solve1(n, b, t[i], ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历每列</span></span><br><span class="line"><span class="comment">// 第二次用作滑动窗口的数组是经过第一次处理后的</span></span><br><span class="line"><span class="keyword">int</span> len = a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">win.clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line"><span class="keyword">while</span>(!win.empty() &amp;&amp; ans[win.back()][i] &lt; ans[j][i])</span><br><span class="line">win.pop_back();</span><br><span class="line"><span class="keyword">while</span>(!win.empty() &amp;&amp; win.front() &lt; j - len + <span class="number">1</span>)</span><br><span class="line">win.pop_front();</span><br><span class="line">win.push_back(j);</span><br><span class="line"><span class="keyword">if</span>(j + <span class="number">1</span> &gt;= len)</span><br><span class="line">ans[j - len + <span class="number">1</span>][i] = ans[win.front()][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - a + <span class="number">1</span>; i ++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - b + <span class="number">1</span>; j ++)sum+=ans[i][j];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-Interval"><a href="#I-Interval" class="headerlink" title="I.Interval"></a>I.Interval</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>There is an interval ${[1, n]}$ initially. For an interval ${[l, r]}$, if ${l &lt; r}$, there will be two possible changes:</p><ul><li>Shrinking, ${[l, r]}$ changes to ${[l + 1, r]}$ or ${[l, r - 1]}$</li><li>Expanding, ${[l, r]}$ changes to ${[l - 1, r]~(l &gt; 1)}$ or ${[l, r + 1]~(r &lt; n)}$</li></ul><p>So, when ${l = r}$, the interval will be unable to be changed. You don’t want to see this, so you may need to ban some changing manners.<br>Specifically, we use tuple ${(l, r, dir, c)}$ to describe banning. If ${dir = L}$, you can ban the bidirectional changing between ${[l, r]}$ and ${[l + 1, r]}$ with cost ${c}$ while you can ban the bidirectional changing between ${[l, r]}$ and ${[l, r - 1]}$ with cost ${c}$ if ${dir = R}$.<br>Determine the minimum total cost to guarantee that ${l = r}$ will never happen. Print “-1” if it’s impossible to make it.</p><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>参见官方题解：<br>这个题的本质就是一个网格图网络流，把每个区间$[l,r]$定到$(l,r)$的位置，其中原点就是$(1,n)$，汇点是$(n,1)$，并把所有$(i,i)$的点跟汇点连一条流量为正无穷的边即可，除此之外没有被限制的两点间也要连流量正无穷的边。<br>这种题一般是转对偶图然后变成最短路，具体请参考题目“狼抓兔子”。<br>时间复杂度$O(n^2\log n)$</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) (x)*(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4000007</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line">ll d[maxn];</span><br><span class="line"><span class="keyword">int</span> N,e1,head[maxn],to[maxn&lt;&lt;<span class="number">1</span>],nex[maxn&lt;&lt;<span class="number">1</span>],vis[maxn],w[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">++e1;nex[e1]=head[u];head[u]=e1;to[e1]=v;w[e1]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) d[i]=inf,vis[i]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;pair&lt;ll,<span class="keyword">int</span>&gt;&gt; q;d[s]=<span class="number">0</span>;q.push(mp(<span class="number">0</span>,s));</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.top().second;q.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nex[i])&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(d[v]&gt;d[u]+w[i])&#123;</span><br><span class="line">d[v]=d[u]+w[i];</span><br><span class="line">q.push(mp(-d[v],v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>||a==n) <span class="keyword">return</span> n*n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="number">0</span>||b==n) <span class="keyword">return</span> n*n+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> (a<span class="number">-1</span>)*n+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> l=read(),r=read();</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">4</span>];<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> x=read();</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">'L'</span>)&#123;</span><br><span class="line">addedge(id(l,r<span class="number">-1</span>),id(l,r),x),addedge(id(l,r),id(l,r<span class="number">-1</span>),x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">addedge(id(l<span class="number">-1</span>,r<span class="number">-1</span>),id(l,r<span class="number">-1</span>),x),addedge(id(l,r<span class="number">-1</span>),id(l<span class="number">-1</span>,r<span class="number">-1</span>),x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">N=n*n+<span class="number">2</span>;</span><br><span class="line">dijkstra(n*n+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,d[n*n+<span class="number">2</span>]==inf?<span class="number">-1</span>:d[n*n+<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-Just-Shuffle"><a href="#J-Just-Shuffle" class="headerlink" title="J.Just Shuffle"></a>J.Just Shuffle</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a permutation with size ${n}$ and an integer ${k}$, you should find a permutation substitution ${P}$ that $\{1, 2, \cdots, n\}$ will become ${A}$ after performing substitution ${P}$ for exactly ${k}$ times. Print the permutation after performing ${P}$ for once on $\{1, 2, \cdots, n\}$. If there are multiple solutions, print any of them. If there is no solution, print “-1” in one line.</p><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>总之就是求置换的$-k$次幂。<br>$k$是质数，不可能有无解情况。<br>先把置换$A$拆成若干个轮换/循环/环。<br>假设环$i$的长度是$r_i$，因此这个环需要运算$inv_i = k−1 \pmod {r_i}$次才能还原成$P$里的环。<br>为了避免求逆，我们可以逆向使用计算循环$k$次幂的公式。<br>循环的第$j$个位置在进行$k$次幂后会出现在循环的$j\times k\bmod r_i$的位置，故可以逆向计算原来$P$中的环。<br>时间复杂度$O(n)$</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,cnt=<span class="number">0</span>,a[maxn],pos[maxn],ans[maxn],ori[maxn],pre[maxn];</span><br><span class="line"><span class="keyword">bool</span> vst[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">vec[cnt].push_back(x);</span><br><span class="line">vst[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!vst[a[x]])Dfs(a[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">pos[a[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="keyword">if</span>(!vst[i]) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">Dfs(i);</span><br><span class="line"><span class="keyword">int</span> size=vec[cnt].size();</span><br><span class="line"><span class="keyword">int</span> x=k%size;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;size; j++)ori[j*x%size]=j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;size; j++)ans[vec[cnt][ori[j]]]=vec[cnt][ori[(j+<span class="number">1</span>)%size]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天A了5题，还算不错，但是AK的队伍好像有点多啊（&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://blog.bill.moe/categories/ACM/"/>
    
    
      <category term="网络流" scheme="https://blog.bill.moe/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最短路径" scheme="https://blog.bill.moe/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="数论" scheme="https://blog.bill.moe/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="比赛酱油记" scheme="https://blog.bill.moe/tags/%E6%AF%94%E8%B5%9B%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
      <category term="平面图转对偶图" scheme="https://blog.bill.moe/tags/%E5%B9%B3%E9%9D%A2%E5%9B%BE%E8%BD%AC%E5%AF%B9%E5%81%B6%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>2020牛客暑期多校训练营（第一场）解题报告</title>
    <link href="https://blog.bill.moe/nowcoder-multischool-1/"/>
    <id>https://blog.bill.moe/nowcoder-multischool-1/</id>
    <published>2020-07-15T05:58:02.000Z</published>
    <updated>2020-07-26T06:32:57.744Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天复健赛，只过了三题，太菜了。</p><a id="more"></a><h2 id="A-B-Suffix-Array"><a href="#A-B-Suffix-Array" class="headerlink" title="A. B-Suffix Array"></a>A. B-Suffix Array</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>The BB-function $B(t_1 t_2 \dots t_k) = b_1 b_2 \dots b_k$ of a string $t_1 t_2 \dots t_k$ is defined as follows.</p><ul><li>If there is an index $j &lt; i$ where $t_j = t_i, b_i = \min_{1 \leq j &lt; i, t_j = t_i}\{i - j\}$,</li><li>Otherwise, $b_i = 0$.</li></ul><p>Given a string $s_1 s_2 \dots s_n$ , sort its $n$ suffixes into increasing lexicographically order of the BB-function.</p><p>Formally, the task is to find a permutaion $p_1, p_2, \dots, p_n$ of $\{1, 2, \dots, n\}$ such that $B(s_{p_{i - 1}} \dots s_n) &lt; B(s_{p_{i}} \dots s_n)$ holds for $i = 2, \dots, n$.</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>大概就是让你对B生成的字符串进行排序，<a href="https://blog.csdn.net/weixin_43965698/article/details/107304525" target="_blank" rel="noopener">这里</a>有一份写的很好的题解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Suffix_Array &#123;</span><br><span class="line"><span class="keyword">int</span> sa[maxn],rk[maxn],fir[maxn],sec[maxn],buc[maxn],tmp[maxn],height[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_buc</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">fill(buc,buc+n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)buc[a[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)buc[i]+=buc[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">fill_buc(n,a);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)rk[i]=buc[a[i]<span class="number">-1</span>]+<span class="number">1</span>; <span class="comment">//calculate single alpha rank</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t&lt;=n; t&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">fir[i]=rk[i]; <span class="comment">//first key</span></span><br><span class="line">sec[i]=(i+t)&gt;n?<span class="number">0</span>:rk[i+t]; <span class="comment">//second key</span></span><br><span class="line">&#125;</span><br><span class="line">fill_buc(n,sec); <span class="comment">//second key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)tmp[n-(--buc[sec[i]])]=i; <span class="comment">//tmp[i] record ith second key's position</span></span><br><span class="line">fill_buc(n,fir); <span class="comment">//first key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)sa[buc[fir[tmp[i]]]--]=tmp[i];</span><br><span class="line"><span class="keyword">bool</span> unique=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,last=<span class="number">0</span>; j&lt;=n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> i=sa[j];</span><br><span class="line"><span class="keyword">if</span>(!last)rk[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fir[i]==fir[last]&amp;&amp;sec[i]==sec[last])rk[i]=rk[last],unique=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> rk[i]=rk[last]+<span class="number">1</span>;</span><br><span class="line">last=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(unique)<span class="keyword">break</span>; <span class="comment">//already unique</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Suffix_Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,b[maxn];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">node(<span class="keyword">int</span> _x=<span class="number">0</span>,<span class="keyword">int</span> _y=<span class="number">0</span>):x(_x),y(_y) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(y-x==b.y-b.x)<span class="keyword">return</span> rk[y+<span class="number">1</span>]&lt;rk[b.y+<span class="number">1</span>]; <span class="comment">//前半部分长度相等</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> y-x&lt;b.y-b.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s) &#123;</span><br><span class="line">s=<span class="string">' '</span>+s;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">'a'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x)b[i]=i-x;</span><br><span class="line"><span class="keyword">else</span> b[i]=<span class="number">0</span>;</span><br><span class="line">x=i;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(y)b[i]=i-y;</span><br><span class="line"><span class="keyword">else</span> b[i]=<span class="number">0</span>;</span><br><span class="line">y=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)b[i]++; <span class="comment">//腾出空位离散化</span></span><br><span class="line">build(n,b);</span><br><span class="line">x=y=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">'a'</span>) &#123;</span><br><span class="line">a[i]=node(i,y);</span><br><span class="line">x=i;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a[i]=node(i,x);</span><br><span class="line">y=i;</span><br><span class="line">&#125;</span><br><span class="line">rk[n+<span class="number">1</span>]=<span class="number">-1</span>,rk[n+<span class="number">2</span>]=<span class="number">-2</span>;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i].x);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Quadratic-Form"><a href="#D-Quadratic-Form" class="headerlink" title="D. Quadratic Form"></a>D. Quadratic Form</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>Bobo has a positive-definite $n \times n$ matrix $A$ and an $n$-dimension vector $b$. He would like to find $x_1, x_2, \dots, x_n$ where </p><ul><li>$x_1, x_2, \dots, x_n \in \mathbb{R}$,</li><li>$\sum_{i = 1}^n \sum_{j = 1}^n A_{i, j} x_i x_j \leq 1$</li><li>$\sum_{i = 1}^n b_i x_i$ is maximum.</li></ul><p>It can be shown that $\left(\sum_{i = 1}^n b_i x_i\right)^2 = \frac{P}{Q}$ , which is rational.</p><p>Find the value of $P \cdot Q^{-1} \bmod 998244353$.</p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>答案就是$b^T A^{-1} b$<br>用高斯约旦消元算矩阵的逆即可</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">405</span>,p=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL A[maxn][maxn],tmp[maxn],B[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Quick_Pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">LL sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>,a=a*a%p)<span class="keyword">if</span>(b&amp;<span class="number">1</span>)sum=sum*a%p;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL x)</span> </span>&#123;<span class="keyword">return</span> Quick_Pow(x,p<span class="number">-2</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Gauss_Jordan</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">LL r=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> row=i;</span><br><span class="line"><span class="keyword">for</span>(; row&lt;=n; row++)<span class="keyword">if</span>(A[row][i])<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(row&gt;n)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(row!=i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)swap(A[i][j],A[row][j]);</span><br><span class="line">r=(p-r)%p;</span><br><span class="line">&#125;</span><br><span class="line">r=r*A[i][i]%p;</span><br><span class="line">LL t=inv(A[i][i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)A[i][j]=A[i][j]*t%p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line"><span class="keyword">if</span>(j!=i) &#123;</span><br><span class="line">t=A[j][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=m; k++)A[j][k]=(A[j][k]-t*A[i][k]%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF) &#123;</span><br><span class="line"><span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span>(A));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[i][j]);</span><br><span class="line">A[i][j]=(A[i][j]+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)A[i][i+n]=<span class="number">1</span>;</span><br><span class="line">Gauss_Jordan(n,n&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;B[i]);</span><br><span class="line">B[i]=(B[i]+p)%p;</span><br><span class="line">&#125;</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">tmp[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)tmp[i]=(tmp[i]+B[j]*A[i][j+n]%p)%p;</span><br><span class="line">ans=(ans+tmp[i]*B[i]%p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Counting-Spanning-Trees"><a href="#E-Counting-Spanning-Trees" class="headerlink" title="E. Counting Spanning Trees"></a>E. Counting Spanning Trees</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>Bobo has a bipartite graph with $(n + m)$ vertices $x_1, x_2, \dots, x_n$ and $y_1, y_2, \dots, y_m$.</p><p>The vertex $x_i$ is connected to the first $a_i$ vertices in $Y$, namely $y_1, \dots, y_{a_i}$.</p><p>Given $n, m, a_1, \dots, a_n$ and $\mathrm{mod}$, find the number of spanning trees of the graph modulo $\mathrm{mod}$.</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>将结点度数从大到小排序，生成数个数就是$\prod_{i &gt;= 2}^n deg(x_i) \prod_{i &gt;= 2}^m deg(y_i)$</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> da[maxn],db[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,mod;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fill(c,c+m+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&gt;=<span class="number">1</span>; i-=lowbit(i))c[i]+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;=m; i+=lowbit(i))ans+=c[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;mod) &#123;</span><br><span class="line">bit.init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;da[i];</span><br><span class="line">bit.add(da[i],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)db[i]=bit.query(i);</span><br><span class="line">sort(da+<span class="number">1</span>,da+n+<span class="number">1</span>,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">sort(db+<span class="number">1</span>,db+m+<span class="number">1</span>,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)ans=ans*da[i]%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=m; i++)ans=ans*db[i]%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Infinite-String-Comparision"><a href="#F-Infinite-String-Comparision" class="headerlink" title="F. Infinite String Comparision"></a>F. Infinite String Comparision</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>For a string $x$, Bobo defines $x^\infty = x x x \dots$, which is $x$ repeats for infinite times, resulting in a string of infinite length.</p><p>Bobo has two strings $a$ and $b$. Find out the result comparing $a^\infty$ and $b^\infty$ in lexicographical order.</p><p>You can refer the wiki page for further information of Lexicographical Order.</p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>两个串对应$\gcd$的位置必须相同，否则两个串就不同，如果不同暴力比较即可。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">string</span> a,b;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b) &#123;</span><br><span class="line"><span class="keyword">int</span> lena=a.length(),lenb=b.length(),posa=<span class="number">0</span>,posb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> gcd=__gcd(lena,lenb);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lcm=<span class="number">1L</span>L*lena/gcd*lenb;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lena; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i%gcd]!=a[i]) flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenb;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i%gcd]!=b[i]) flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"="</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lcm; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[posa]&lt;b[posb]) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"&lt;"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[posa]&gt;b[posb]) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"&gt;"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">posa++;</span><br><span class="line">posb++;</span><br><span class="line"><span class="keyword">if</span>(posa==lena)posa=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(posb==lenb)posb=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Minimum-cost-Flow"><a href="#H-Minimum-cost-Flow" class="headerlink" title="H. Minimum-cost Flow"></a>H. Minimum-cost Flow</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>Bobo has a network of $n$ nodes and $m$ arcs. The $i$-th arc goes from the $a_i$-th node to the $b_i$-th node, with cost $c_i$.</p><p>Bobo also asks $q$ questions. The $i$-th question is specified by two integers $u_i$ and $v_i$, which is to ask the minimum cost to send one unit of flow from the $1$-th node to the $n$-th node, when all the edges have capacity $\frac{u_i}{v_i}$ (a fraction).</p><p>You can refer the wiki page for further information of Minimum-cost Flow.</p><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>这道题非常机智，可惜我考试的时候没想到是队友想到的。<br>定义费用流$cost(c,f)$表示容量为$c$，流量为$f$时的费用流总费用。</p><script type="math/tex; mode=display">cost(c,1) = cost(c * \frac 1c, \frac1c) * c = cost(1,\frac 1c) * c</script><p>这样我们就可以把分数容量转化为相对的分数流量，跑网络流就轻松多了。<br>我们用EK费用流，每次留一个单位的流量，记录下每个单位流量所花费的费用，即可根据不同的询问计算不同的费用，跑一次费用流即可。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">405</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">LL from,to,cap,flow,cost;</span><br><span class="line">Edge(LL x=<span class="number">0</span>,LL y=<span class="number">0</span>,LL c=<span class="number">0</span>,LL f=<span class="number">0</span>,LL co=<span class="number">0</span>):from(x),to(y),cap(c),flow(f),cost(co) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LL per[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MinimumCost_MaximumFlow</span> &#123;</span> <span class="comment">//EK Edition</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt;edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;G[maxn];</span><br><span class="line"><span class="keyword">bool</span> inque[maxn];</span><br><span class="line">LL a[maxn],dist[maxn];</span><br><span class="line"><span class="keyword">int</span> path[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;n=n;</span><br><span class="line">edges.clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,LL v,LL f)</span> </span>&#123;</span><br><span class="line">edges.push_back(Edge(x,y,v,<span class="number">0</span>,f));</span><br><span class="line">edges.push_back(Edge(y,x,<span class="number">0</span>,<span class="number">0</span>,-f));</span><br><span class="line">m=edges.size();</span><br><span class="line">G[x].push_back(m<span class="number">-2</span>);</span><br><span class="line">G[y].push_back(m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellmanford</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,LL&amp; flow,LL&amp; cost)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)dist[i]=LLONG_MAX/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">Q.push(s);</span><br><span class="line">dist[s]=path[s]=<span class="number">0</span>;</span><br><span class="line">a[s]=LLONG_MAX/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> Now=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">inque[Now]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> id:G[Now]) &#123;</span><br><span class="line">Edge&amp; e=edges[id];</span><br><span class="line"><span class="keyword">int</span> Next=e.to;</span><br><span class="line"><span class="keyword">if</span>(e.cap&gt;e.flow&amp;&amp;dist[Next]&gt;dist[Now]+e.cost) &#123;</span><br><span class="line">dist[Next]=dist[Now]+e.cost;</span><br><span class="line">path[Next]=id;</span><br><span class="line">a[Next]=min(a[Now],e.cap-e.flow);</span><br><span class="line"><span class="keyword">if</span>(!inque[Next]) &#123;</span><br><span class="line">Q.push(Next);</span><br><span class="line">inque[Next]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dist[t]==LLONG_MAX/<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">flow+=a[t];</span><br><span class="line">cost+=dist[t]*a[t];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Now=t; Now!=s; Now=edges[path[Now]].from) &#123;</span><br><span class="line">edges[path[Now]].flow+=a[t];</span><br><span class="line">edges[path[Now]^<span class="number">1</span>].flow-=a[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">maxflow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,LL&amp; cost)</span> </span>&#123;</span><br><span class="line">LL flow=<span class="number">0</span>;</span><br><span class="line">cost=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bellmanford(s,t,flow,cost))per[flow]=cost;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line">&#125; mcmf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFrac</span><span class="params">(LL u,LL d)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>,u/__gcd(u,d),d/__gcd(u,d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF) &#123;</span><br><span class="line">mcmf.init(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">LL x,y,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;v);</span><br><span class="line">mcmf.AddEdge(x,y,<span class="number">1</span>,v);</span><br><span class="line">&#125;</span><br><span class="line">LL cost=<span class="number">0</span>;</span><br><span class="line">LL flow=mcmf.maxflow(<span class="number">1</span>,n,cost);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=q; i++) &#123;</span><br><span class="line">LL u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;u,&amp;v);</span><br><span class="line"><span class="keyword">if</span>(flow*u&lt;v) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NaN"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL intt=v/u;</span><br><span class="line">printFrac(per[intt]*u+(intt==flow?<span class="number">0</span>:(per[intt+<span class="number">1</span>]-per[intt])*(v-intt*u)),v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-1-or-2"><a href="#I-1-or-2" class="headerlink" title="I. 1 or 2"></a>I. 1 or 2</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>Bobo has a graph with $n$ vertices and $m$ edges where the $i$-th edge is between the vertices $a_i$ and $b_i$. Find out whether is possible for him to choose some of the edges such that the $i$-th vertex is incident with exactly $d_i$ edges.</p><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>拆点拆边<br>对于两边度数都为2的边$e(x,y)$，拆成以下5条边：</p><ul><li>$(x, e) (x’, e)$</li><li>$(y, e’) (y’, e’)$</li><li>$(e, e’)$</li></ul><p>然后跑带花树即可</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100007</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],nex[maxn],to[maxn],n;</span><br><span class="line"><span class="keyword">int</span> mate[maxn],link[maxn],vis[maxn], fa[maxn];</span><br><span class="line"><span class="keyword">int</span> que[maxn],hd,tl,e1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">++e1;nex[e1]=head[u];head[u]=e1;to[e1]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fa[x]==x?x:fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ss[maxn],tim;</span><br><span class="line">++tim;</span><br><span class="line"><span class="keyword">while</span>(ss[x]!=tim)&#123;</span><br><span class="line"><span class="keyword">if</span>(x) &#123;ss[x]=tim;x=find(link[mate[x]]);&#125;</span><br><span class="line">swap(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Flower</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(find(x)!=p)&#123;</span><br><span class="line">link[x]=y;</span><br><span class="line">fa[y=mate[x]]=(fa[x]=p);</span><br><span class="line"><span class="keyword">if</span>(vis[y]==<span class="number">1</span>) vis[que[++tl]=y]=<span class="number">2</span>;</span><br><span class="line">x=link[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">hd=<span class="number">1</span>;tl=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vis[fa[i]=i]=<span class="number">0</span>;</span><br><span class="line">vis[que[++tl]=x]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(hd&lt;=tl)&#123;</span><br><span class="line">x=que[hd++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nex[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> u=to[i];</span><br><span class="line"><span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">link[u]=x;</span><br><span class="line"><span class="keyword">if</span>(!mate[u])&#123;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">x=mate[link[u]];</span><br><span class="line">mate[mate[u]=link[u]]=u;</span><br><span class="line">u=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> vis[que[++tl]=mate[u]] = <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[u]==<span class="number">2</span>&amp;&amp;find(u)!=find(x)) &#123;</span><br><span class="line"><span class="keyword">int</span> p=LCA(x,u);</span><br><span class="line">Flower(x,u,p);</span><br><span class="line">Flower(u,x,p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d[maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) head[i]=mate[i]=<span class="number">0</span>;</span><br><span class="line">e1=ans=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">addedge(u,v);addedge(v,u);</span><br><span class="line"><span class="keyword">if</span>(!mate[u]&amp;&amp;!mate[v])</span><br><span class="line">mate[mate[u]=v]=u,++ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nn,m;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;nn,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line">n=nn*<span class="number">2</span>+m*<span class="number">2</span>;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nn;i++) d[i]=read(),tot+=d[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">add(u,nn*<span class="number">2</span>+i);</span><br><span class="line"><span class="keyword">if</span>(d[u]==<span class="number">2</span>) add(nn*<span class="number">2</span>+i,u+nn);</span><br><span class="line">add(v,nn*<span class="number">2</span>+m+i);</span><br><span class="line"><span class="keyword">if</span>(d[v]==<span class="number">2</span>) add(nn*<span class="number">2</span>+m+i,v+nn);</span><br><span class="line">add(nn*<span class="number">2</span>+i,nn*<span class="number">2</span>+m+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span>(!mate[i]&amp;&amp;match(i)) ++ans;</span><br><span class="line"><span class="keyword">if</span>(tot%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;ans==m+tot/<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">  <span class="comment">//  for (int i = 1; i &lt;= n; ++i)</span></span><br><span class="line"><span class="comment">//printf("%d ",mate[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-Easy-Integration"><a href="#J-Easy-Integration" class="headerlink" title="J. Easy Integration"></a>J. Easy Integration</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given $n$, find the value of $\int_{0}^1 (x - x^2)^n \mathrm{d} x$</p><p>It can be proved that the value is a rational number $\frac{p}{q}$.</p><p>Print the result as $(p \cdot q^{-1}) \bmod 998244353$.</p><h3 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h3><p>答案是$\frac{(n!)^2}{(2n+1)!}$</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mo = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> fac[maxn];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">res *= a;</span><br><span class="line">res %= mo;</span><br><span class="line">&#125;</span><br><span class="line">a *= a;</span><br><span class="line">a %= mo;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> qpow(x,mo<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++) fac[i] = (fac[i<span class="number">-1</span>] * i) % mo;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = fac[<span class="number">2</span> * n + <span class="number">1</span>];</span><br><span class="line">ans = (ans * qpow(inv(fac[n]),<span class="number">2</span>)) % mo;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,inv(ans));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天复健赛，只过了三题，太菜了。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://blog.bill.moe/categories/ACM/"/>
    
    
      <category term="高斯消元" scheme="https://blog.bill.moe/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="网络流" scheme="https://blog.bill.moe/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="后缀数组" scheme="https://blog.bill.moe/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
      <category term="比赛酱油记" scheme="https://blog.bill.moe/tags/%E6%AF%94%E8%B5%9B%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
      <category term="费用流" scheme="https://blog.bill.moe/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="带花树" scheme="https://blog.bill.moe/tags/%E5%B8%A6%E8%8A%B1%E6%A0%91/"/>
    
      <category term="生成树计数" scheme="https://blog.bill.moe/tags/%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>2020 CCPC wannafly 冬令营 Day3 游记+解题报告</title>
    <link href="https://blog.bill.moe/wannafly-camp-day4/"/>
    <id>https://blog.bill.moe/wannafly-camp-day4/</id>
    <published>2020-02-11T02:33:06.000Z</published>
    <updated>2020-07-12T13:40:37.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文章施工中……<br>进度<code>[===&gt;　　　　　　　　] 2/10 20%</code></p><a id="more"></a><h2 id="A-Alternative-Accounts"><a href="#A-Alternative-Accounts" class="headerlink" title="A. Alternative Accounts"></a>A. Alternative Accounts</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>Everybody knows that jiry_2 = Syloviaely.<br>There are $n$ different accounts on the website, and some of them competed in the recent $k$ contests. However, Mike suspects that there are lots of alternative accounts.<br>There are axioms believed by everyone that nobody can use two different in one contest simultaneously and each account can be owned by only one person. So different accounts without overlapping contest participation can be owned by the same person.<br>Mike wants to know the minimum possible number of different people behind these accounts.</p></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目意思就是给三个相交的完全图，求最少染色数。<br>考虑一下，$A\cap B\cap C,(A\cap B)-C,(A\cap C)-B,(B\cap C)-A$都是需要染不同颜色的，否则由于两两处于完全图中，必定会染色失败。<br>而$A-B-C$与$B\cap C-A$是可以染相同颜色的，同理其他两种情况一样。<br>故答案就是：  </p><script type="math/tex; mode=display">\left|A\cap B\cap C\right|+\left|(A\cap B)-C\right|+\left|(A\cap C)-B\right|+\left|(B\cap C)-A\right| \\ +\max(0,\left|A-B-C\right|-\left|B\cap C-A\right|,\left|B-A-C\right|-\left|A\cap C-B\right|,\left|C-A-B\right|-\left|A\cap B-C\right|)</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">k=Get_Int();</span><br><span class="line"><span class="keyword">if</span>(k&lt;=<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)Get_Int();</span><br><span class="line">ans=max(m,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S1,S2,S3,S12,S23,S13,S123;</span><br><span class="line"><span class="keyword">int</span> m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)S1.insert(Get_Int());</span><br><span class="line">m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)S2.insert(Get_Int());</span><br><span class="line">m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)S3.insert(Get_Int());</span><br><span class="line">set_intersection(S1.begin(),S1.end(),S2.begin(),S2.end(),inserter(S12,S12.begin()));</span><br><span class="line">set_intersection(S2.begin(),S2.end(),S3.begin(),S3.end(),inserter(S23,S23.begin()));</span><br><span class="line">set_intersection(S1.begin(),S1.end(),S3.begin(),S3.end(),inserter(S13,S13.begin()));</span><br><span class="line">set_intersection(S12.begin(),S12.end(),S3.begin(),S3.end(),inserter(S123,S123.begin()));</span><br><span class="line"><span class="keyword">int</span> s123=S123.size();</span><br><span class="line"><span class="keyword">int</span> s12=S12.size()-s123,s23=S23.size()-s123,s13=S13.size()-s123;</span><br><span class="line"><span class="keyword">int</span> s1=S1.size()-s12-s13-s123,s2=S2.size()-s12-s23-s123,s3=S3.size()-s13-s23-s123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s12+s23+s13+s123+max(<span class="number">0</span>,max(s1-s23,max(s2-s13,s3-s12))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Bitset-Master"><a href="#B-Bitset-Master" class="headerlink" title="B. Bitset Master"></a>B. Bitset Master</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>It’s well known in China that $O(n^2)$ algorithms can pass the problem with $n=10^6$ easily.<br>You are given a tree with $n$ vertices and $n-1$ edges $(u_1, v_1), (u_2, v_2), \dots, (u_{n-1},v_{n-1})$<br>For each vertex $u$,there is a set $S_u=\{u\}$ initially.<br>You need to perform $m$ operations. For the $i$-th operation, you are given an edge $p_i$ and let $S_{u_{p_i}}$ and $S_{v_{p_i}}$ be the union of them.<br>Finally, you need to find the number of sets $S(v)$ contains $u$ for each vertex $u$.  </p></blockquote><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>将包含$v$的集合看做，$v$能到达的集合。<br>由于后合并的集合可以使前面的点到达，但先合并的集合不能使后面的点到达，故倒过来考虑，维护每个集合的大小即可统计出每个点可以到达多少个集合。  </p><p>如何快速维护集合大小？  </p><script type="math/tex; mode=display">\left|S_u\right|=\left|S_v\right|=\left|S_u\right|+\left|S_v\right|-\left|S_u\cap S_v\right|</script><p>而$\left|S_u\cap S_v\right|$的大小就是上一次的$S_u,S_v$合并后的大小。  </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,u[maxn],v[maxn],p[maxn],f[maxn],last[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)u[i]=Get_Int(),v[i]=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)p[i]=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)f[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> x=u[p[i]],y=v[p[i]];</span><br><span class="line">last[p[i]]=f[x]=f[y]=f[x]+f[y]-last[p[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">printf</span>(<span class="string">"%d%c"</span>,f[i],i==n?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文章施工中……&lt;br&gt;进度&lt;code&gt;[===&amp;gt;　　　　　　　　] 2/10 20%&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://blog.bill.moe/categories/ACM/"/>
    
    
      <category term="比赛酱油记" scheme="https://blog.bill.moe/tags/%E6%AF%94%E8%B5%9B%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>将用户看做有温度的人 —— 浅谈哔哩哔哩及其社区经济</title>
    <link href="https://blog.bill.moe/talks-bilibili/"/>
    <id>https://blog.bill.moe/talks-bilibili/</id>
    <published>2020-02-09T12:08:56.000Z</published>
    <updated>2020-07-12T13:40:37.680Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好久没写杂文了憋得慌，近来看了很多关于B站的文章，作为一个长年B站用户深有共鸣，故作杂文一篇。<br>想写的东西有点多，不急着全部写完，一点一点写希望能作出一篇有深度的文章。文笔不好还请多多包涵。  </p><img src="/talks-bilibili/66001476_p0.jpg">  <p><em>pid:66001476，侵删致歉。</em></p><a id="more"></a><p>B站已经有10周年了，从最开始不起眼的小破站，到现在国内最大的ACG文化交流平台，有太多值得我们回味感慨。<br>但近期有关“B站变质”的负面消息越来越多，让我们不禁认真思考：B站应该是什么，B站变质了吗？</p><h2 id="B站变质了吗？"><a href="#B站变质了吗？" class="headerlink" title="B站变质了吗？"></a>B站变质了吗？</h2><p>随着B站发展壮大，伴随着以下现象的出现：  </p><ol><li>加入贴片广告</li><li>大会员机制</li><li>首页推荐列表广告</li><li>视频质量下降</li><li>低俗内容</li></ol><p>下面我们简单聊一聊这几项。</p><h3 id="贴片广告的加入"><a href="#贴片广告的加入" class="headerlink" title="贴片广告的加入"></a>贴片广告的加入</h3><p>不管是黑B站的人，还是洗B站的人，都喜欢拿陈总（书记）的官方澄清下手。遗憾的是，我也将从官方澄清讲起，从这些澄清里面，我们究竟能看出什么？  </p><p><a href="https://www.zhihu.com/question/46667028/answer/102445298" target="_blank" rel="noopener">如何看待哔哩哔哩曾承诺永远不加广告，而现在却在加了贴片广告？ - 知乎问答</a></p><img src="/talks-bilibili/2020-02-09T212852.png">  <p>此处的“核心版权方”指的是东电，而“某家同行”是谁也不必多说了。<br>我们注意到，此处B站是被迫加入广告，而非主动加入广告，而加入的广告也是2233娘的表情包，这在广告方面毫无经济价值。  </p><img src="/talks-bilibili/2020-02-09T213805.png">  <p>我们完全可以想象出那些去举报了B站伪广告后跑来喷B站不遵守承诺添加广告的“热心群众”的丑恶脸嘴。  </p><p>陈总也对此事作出了郑重道歉，这堪称是一次完美的公关。可以看出，B站是诚心诚意地向我们道歉，又为何不可接受呢？尚且，承包番剧达到标准后就不会再次出现贴片广告。在之后和东电的矛盾中，B站也选择了重拳出击而不是一让再让。<br>要明白，我们的敌人是“某家同行”，而不是被迫采取自卫手段的B站，在这种情况内讧岂不是正合了那家同行的心意吗？<br>总而言之，贴片广告完全不是B站本意，加入贴片广告也是无奈之举，不足以构成“B站变质”的理由。  </p><h3 id="大会员机制及首页推荐列表广告"><a href="#大会员机制及首页推荐列表广告" class="headerlink" title="大会员机制及首页推荐列表广告"></a>大会员机制及首页推荐列表广告</h3><p>我们一般把大会员称作是大忽悠，当然这只是个梗，请勿当真。  </p><p><a href="https://www.zhihu.com/question/367851114" target="_blank" rel="noopener">如何看待 b 站新番全部都是大会员，且大部分老番都加了大会员专享，非会员用户已经看不了多少番剧了? - 知乎问题</a></p><p><a href="https://www.zhihu.com/question/362451250" target="_blank" rel="noopener">B站大会员是否也是一种vvip？ - 知乎问题</a>  </p><p>首先我们需要知道，B站的用户分为四个级别：</p><ul><li>游客（未注册未登录的用户）</li><li>普通用户（登录但没有通过答题的用户）</li><li>普通会员（登录且通过答题的用户）</li><li>大会员（付费用户）</li></ul><p>当你是游客时，你就可以观看B站大部分原创视频了。而普通用户也只是提供了一个储存账号的功能，只有普通会员以上的等级时才能拥有发送评论和弹幕的权利。<br>而通过答题的用户又根据等级增长机制分为Lv1~Lv6，随着等级增长将会解锁更多权益。  </p><p>也就是说，B站大会员是唯一需要付费才能获得的权益，不同于爱奇艺，腾讯视频等平台。B站大会员开通与否的权益写的明明白白，且不会再有未经明面说明的二次收费。反观爱奇艺与腾讯视频，二次收费的条款深深地藏在用户条例中。  </p><img src="/talks-bilibili/2020-02-09T224443.png">  <p>因此，根本不能说B站大会员是一种VVIP。  </p><p>而不少人所攻击的陈总关于大会员的承诺：<br><img src="/talks-bilibili/2020-02-09T224753.png">  </p><p>“口口声声说大会员才能看的新番不能有，现在全部收费，露出了资本家欺骗用户的丑恶用心。”<br>然而我并没有看出陈总有哪里欺骗了用户？<br>首先，陈总承诺的是“<strong>新番无广告</strong>”，<strong>没有承诺“B站无广告”</strong>。其次，“<strong>不会影响目前B站的现有功能和体验</strong>”，<strong>没有承诺“会不会影响较为久远的之后B站的功能和体验”</strong>。再次，“<strong>只有大会员才能看的新番不会有</strong>”，现在的新番有没有大会员的区别仅在于能否提前一周看到新一集，且陈总也没有承诺“<strong>不会有只有大会员才能看的已完结的番</strong>”。  </p><p>你可能会说，事后来扣事前的字眼很没意思，B站现在大多数功能都需要付费，和以前大不一样了，所以变质了。<br>不，我仍然不同意你的观点，在我看来，B站并不是变质了，而是成长了。<br>正如知乎用户 <em>老邪说电影</em> 所言：  </p><blockquote><p>如果把B站比作一个人，那么前几年，它就像个3～4岁的娃娃，长的可爱，像个瓷娃娃，听话、暖心，满足你的一切期望；<br>但是过几年，他突然长大了成了不良少年，开始不听话，外观也不像小时候一样可爱了，偶尔还犯点小错，这时候你还能容忍；<br>再过了几年，他开始为柴米油盐到处奔走，有时候不得不在别人的非议下，去贴个小广告，但是又由于过于年轻，还不熟悉这个世界的规则，在贴小广告的时候，总是有那么些不合时宜。<br>这时候你站出来觉得，他已经变质了，是个低俗的人。<br>绝大多数的B站用户，其实都在白嫖，但对于B站来说，商业化行为才能支撑运营成本，谁能保证能靠着情怀，连续5年甚至10年，自己掏钱为别人服务，那么我觉得你才有资格质疑别人为什么要赚钱。  </p></blockquote><p>运营一个网站需要巨大的费用，B站的收益来源只有：  </p><ul><li>游戏</li><li>直播</li><li>广告</li><li>大会员</li></ul><p>如果每一个人都白嫖B站中绝大部分的资源，B站是无法持久地运作下去的，正如某位孙姓带明星所言：“要恰饭的嘛”。B站是一个企业，想要B站继续稳定发展，做大做强做好，付费是决不可少的。  </p><p>而我要说的是，购买大会员，绝对不亏，甚至血赚。<br>B站大会员一年原价是148RMB连续包年。但经常都会举办活动，最低的时候是每年10月10日大会员打折，最低24一年，没错就是一年（这里24元是6级会员才可购买，5级为49，4级为74，其它等级98）。<br>而B站大会员的权益呢？有下面几条：  </p><ol><li>新番提前看</li><li>所有老番免费看</li><li>哔哩哔哩矿产无限公司购入版权的电影均可观看</li><li>游戏福利</li><li>每月返5B币券（1B币=1RMB）以及10元会员购代金券</li><li>线下活动福利</li></ol><img src="/talks-bilibili/46804727_p0.jpg"><p><em>pid:46804727，侵删致歉。</em></p><p>不少用户都秉持着这么一个态度：我会为优质的服务付费，但不会为低俗的内容付费。<br>于是我们谈到下一个问题。  </p><h3 id="视频质量下降及出现低俗内容"><a href="#视频质量下降及出现低俗内容" class="headerlink" title="视频质量下降及出现低俗内容"></a>视频质量下降及出现低俗内容</h3><p>（咕咕咕中…）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写杂文了憋得慌，近来看了很多关于B站的文章，作为一个长年B站用户深有共鸣，故作杂文一篇。&lt;br&gt;想写的东西有点多，不急着全部写完，一点一点写希望能作出一篇有深度的文章。文笔不好还请多多包涵。  &lt;/p&gt;
&lt;img src=&quot;/talks-bilibili/66001476_p0.jpg&quot;&gt;  
&lt;p&gt;&lt;em&gt;pid:66001476，侵删致歉。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="https://blog.bill.moe/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="https://blog.bill.moe/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>「通知」博客已添加夜间（暗色调）模式</title>
    <link href="https://blog.bill.moe/dark-mode/"/>
    <id>https://blog.bill.moe/dark-mode/</id>
    <published>2020-02-02T14:47:53.000Z</published>
    <updated>2020-07-12T13:40:37.667Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>利用<code>prefers-color-scheme</code>给博客加了个夜间模式。<br>博客将无缝的选择与用户设备相匹配的主题。  </p><a id="more"></a><p><img src="/dark-mode/3.png" alt></p><p>目前支持的环境有：iOS 13, macOS 10.14(Mojave), Android 10, Windows 1809。<br>支持的浏览器有：<br><img src="/dark-mode/1.png" alt>  </p><p>使用方法：只需更改系统主题，即可切换夜间模式，无需刷新或者点击网页。<br>如：在Windows中修改主题颜色：<br><img src="/dark-mode/2.png" alt><br>或调整系统环境至夜间模式。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用&lt;code&gt;prefers-color-scheme&lt;/code&gt;给博客加了个夜间模式。&lt;br&gt;博客将无缝的选择与用户设备相匹配的主题。  &lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://blog.bill.moe/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://blog.bill.moe/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://blog.bill.moe/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>2020 CCPC wannafly 冬令营 Day3 游记+解题报告</title>
    <link href="https://blog.bill.moe/wannafly-camp-day3/"/>
    <id>https://blog.bill.moe/wannafly-camp-day3/</id>
    <published>2020-01-30T08:42:05.000Z</published>
    <updated>2020-07-12T13:40:37.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文章施工中……<br>进度<code>[===================&gt;] 10/10 100%</code><br>施工完成。</p><a id="more"></a><h2 id="A-托米的字符串"><a href="#A-托米的字符串" class="headerlink" title="A. 托米的字符串"></a>A. 托米的字符串</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>小D面前有$n$个黑色的气球。<br>假设第$i$个黑色气球的高度是一个正整数$h_i$，现在小D知道了任意两个不同气球的高度之和，你能帮小D还原出每个黑色气球的具体高度嘛？</p></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>签到题，特判一下$n=2$的情况即可。  </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>来自cyy的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> mt[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;mt[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mt[<span class="number">1</span>][<span class="number">2</span>] == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"1 1\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No Answer\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> x1 = (mt[<span class="number">1</span>][<span class="number">2</span>] + mt[<span class="number">1</span>][<span class="number">3</span>] - mt[<span class="number">2</span>][<span class="number">3</span>]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,x1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">" %d"</span>,mt[<span class="number">1</span>][i]-x1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="B-小吨的点分治"><a href="#B-小吨的点分治" class="headerlink" title="B. 小吨的点分治"></a>B. 小吨的点分治</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>有一天，小吨向火山哥请教了点分治的写法。火山哥教了小吨如下的点分治算法:  </p><ul><li>初始时当前连通块是整棵树。</li><li>首先，在当前连通块中找到任意一个点$u$作为该次的分治中心（不必是重心）。</li><li>其次，把点$u$在当前连通块中删去，可以得到若干个连通块。对于每个连通块再递归进行这样的操作。</li></ul><p>不难发现，小吨从黑心火山哥那里学到的点分治在最坏情况下递归层数可以达到$O(n)$层。现在，好奇的小吨想要知道，对于一棵给定的包含$n$个节点的树，他有多少种不同的点分治方案呢？因为答案可能很大，你只需要输出它对$10^9+7$取模的值即可。<br>两种点分治方案不同当且仅当某一个连通块所选的点分治中心不同。<br>为了避免因为大家所学算法的具体细节不同出现歧义，我们还提供了一份暴力代码来具体描述这个算法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5005</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">view_all</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cur,<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">cur.push_back(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p: e[x])&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[p]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (p == fa) <span class="keyword">continue</span>;</span><br><span class="line">view_all(cur, p, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">view_all(cur, x, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w: cur)&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">vis[w] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p: e[w])&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[p]) <span class="keyword">continue</span>;</span><br><span class="line">res = <span class="number">1l</span>l * res * calc(p) % mod;</span><br><span class="line">&#125;</span><br><span class="line">vis[w] = <span class="number">0</span>;</span><br><span class="line">ans = (ans + res) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_ans</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> calc(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>题解ppt讲得很好了，由于不需要考虑重心的影响，故：</p><blockquote><p>假设我们已经对一棵树进行了点分治得到对应的点分树。如果我们删去原树中的一条边，把得到的两个连通块中的点分别称为黑点和白点。对于点分树中的每个白点（黑点），我们找到它的祖先中最近的一个白点（黑点）作为它新的父亲，这样就能得到两棵全由白点组成的树和全由黑点组成的树（因为有且仅有一个白点和黑点找不到同色的祖先），它们分别为原树切分得到的两棵树的点分树。<br>反过来再考虑，如果我们把两棵树通过一条边$(u,v)$连接起来，我们怎样把原有的两棵点分树合并起来，并且保持原本点分树中的祖先后代关系呢？可以发现，我们只要把$u$到所在点分树根节点的路径以及$v$到所在点分树根节点的路径按任意顺序归并起来即可。  </p></blockquote><p>因此可以使用树形DP解决这个问题，合并的时候我们只需要关心树的根结点所在点分树的深度。<br>设$f(i,j)$表示，树根为$i$，$i$在点分树中深度为$j$的点分治方案数。<br>有：  </p><script type="math/tex; mode=display">f'(x,i)=\sum_{j=1}^i\sum_{k=i-j}^nf(x,j)\cdot f(y,k)\cdot\begin{pmatrix}i-1 \\ j-1\end{pmatrix}</script><p>普通的树形DP是$O(n^2)$的，其中$f(y,k)$可以做个前缀和降到$O(n^3)$。又观察到这是一个用树上背包的真实结点为代价进行转移的方程，故限制转移条件就可以做到$O(n^2)$了，详见<a href="/DP-backpack-notes/#优化1（achen优化）">这里</a>。  </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5005</span>,p=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,Size[maxn];</span><br><span class="line">LL f[maxn][maxn],sum[maxn][maxn],tmp[maxn],C[maxn][maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;edges[x].push_back(y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreeDp</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">Size[Now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)f[Now][i]=<span class="number">0</span>;</span><br><span class="line">f[Now][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">if</span>(Next==fa)<span class="keyword">continue</span>;</span><br><span class="line">TreeDp(Next,Now);</span><br><span class="line">Size[Now]+=Size[Next];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=Size[Now]-Size[Next]; i++)tmp[i]=f[Now][i],f[Now][i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=Size[Now]; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=min(i<span class="number">-1</span>,Size[Next]); j&gt;=<span class="number">0</span>&amp;&amp;i-j&lt;=Size[Now]-Size[Next]; j--)</span><br><span class="line">f[Now][i]=(f[Now][i]+tmp[i-j]*sum[Next][j]%p*C[i<span class="number">-1</span>][i-j<span class="number">-1</span>]%p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=Size[Now]; i&gt;=<span class="number">0</span>; i--)sum[Now][i]=(sum[Now][i+<span class="number">1</span>]+f[Now][i])%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">C[i][<span class="number">0</span>]=C[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)C[i][j]=(C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),y=Get_Int();</span><br><span class="line">AddEdge(x,y);</span><br><span class="line">AddEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">TreeDp(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-无向图定向"><a href="#C-无向图定向" class="headerlink" title="C. 无向图定向"></a>C. 无向图定向</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>火山哥手里有一个$n$个点$m$条边的无向图。<br>现在，火山哥请你把无向图的每条边确定一个方向，使之成为一个DAG，并且最小化最长路的长度。<br>这里一条路径的长度指的是经过边的数量。</p></blockquote><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>题解表示这道题是eazy。<br>过题人数表示这道题是eazy。<br>但是为什么我们就没想出来呢？！！一点都不eazy好吧！  </p><p>这道题可以用到Dilworth定理来思考，也可以不用，但是用了Dilworth可能可以更好理解<del>（可以装逼）</del>  </p><blockquote><p>Dilworth定理：偏序集能划分成的最少的全序集个数等于最大反链的元素个数。  </p></blockquote><p>本题原本要求最长路的最小长度，我们假设偏序集为点对无法连通，则反链为点对能连通的偏序关系，则最长反链为最长路。<br>根据Dilworth定理，可以转化为最少全序集的个数。也就是原题题意变为将无向图定向后，将点集划分为若干个集合，满足集合内的点两两不连通，最小化这样的集合数目。也就是最小化独立集的数目。  </p><p>（上述说明从偏序应满足的性质考虑有问题，尚未想到如何修改）</p><p>可以证明，在原无向图中随意找出一个两两不连边的点集，总有一种定向方案使得它们在有向图中是一个独立集。（证明之后再讲）<br>那么这道题就变成一个简单的状压DP了。  </p><p>另一种不用Dilworth定理的思考方法：<br><img src="/wannafly-camp-day3/1.png"><br>上面第一种方法的证明同样可以用图中分层编号的思想证明。  </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">20</span>][<span class="number">20</span>],Disable[<span class="number">1</span>&lt;&lt;<span class="number">17</span>],f[<span class="number">1</span>&lt;&lt;<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),y=Get_Int();</span><br><span class="line">a[x][y]=a[y][x]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">1</span>; S&lt;(<span class="number">1</span>&lt;&lt;n); S++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">if</span>(S&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line"><span class="keyword">if</span>((S&gt;&gt;(j<span class="number">-1</span>)&amp;<span class="number">1</span>)&amp;&amp;a[i][j])Disable[S]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">1</span>; S&lt;(<span class="number">1</span>&lt;&lt;n); S++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> T=S; T; T=S&amp;(T<span class="number">-1</span>))</span><br><span class="line"><span class="keyword">if</span>(!Disable[T])f[S]=min(f[S],f[S^T]+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-求和"><a href="#D-求和" class="headerlink" title="D. 求和"></a>D. 求和</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>令$f(n)=\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j,n)$，求$\sum_{i=1}^n f(i)$<br>请输出答案对$mod$取模的值。保证$mod$是个质数。  </p></blockquote><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>简单莫比乌斯反演，就是打这篇题解有点麻烦。  </p><script type="math/tex; mode=display">\begin{aligned}f(i)&=\sum_{d\mid i}d\sum_{j=1}^i\sum_{k=1}^i[\gcd(i,j,k)=d] \\&=\sum_{d\mid i}d\sum_{j=1}^{\frac id}\sum_{k=1}^{\frac id}[\gcd(\frac id,j,k)=1] \\&=\sum_{d\mid i}d\sum_{j=1}^{\frac id}\sum_{k=1}^{\frac id}\sum_{t\mid\frac id,t\mid j,t\mid k}\mu(t) \\&=\sum_{d\mid i}d\sum_{t\mid\frac id}\mu(t)(\frac i{dt})^2 \\&=\sum_{T\mid i}(\frac iT)^2\sum_{d\mid T}d\mu(\frac Td) \\&=\sum_{T\mid i}(\frac iT)^2\varphi(T)\end{aligned}</script><p>故：  </p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^nf(i)&=\sum_{i=1}^n\sum_{T\mid i}(\frac iT)^2\varphi(T) \\&=\sum_{T=1}^n\varphi(T)\sum_{i=kT}^n(\frac iT)^2 \\&=\sum_{T=1}^n\varphi(T)\frac{\lfloor\frac nT\rfloor(\lfloor\frac nT\rfloor+1)(2\lfloor\frac nT\rfloor+1)}6\end{aligned}</script><p>用杜教筛处理欧拉函数，用数论根号分块计算答案，故时间复杂度为：  </p><script type="math/tex; mode=display">T(n)=\sum_{i=1}^{\sqrt n}i^{\frac 23}+\sum_{i=1}^{\sqrt n}(\frac ni)^{\frac 23}</script><p>根据积分可得$T(n)=O(n^{\frac 56})$</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL limit=<span class="number">1000000</span>,hashmod=<span class="number">999959</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vst[limit+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,Prime[limit+<span class="number">5</span>];</span><br><span class="line">LL n,mod,Phi[limit+<span class="number">5</span>],inv2,inv6;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; Hash[hashmod+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Table</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">Phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vst[i]) &#123;</span><br><span class="line">Prime[++cnt]=i;</span><br><span class="line">Phi[i]=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=cnt&amp;&amp;i*Prime[j]&lt;=n; j++) &#123;</span><br><span class="line">vst[i*Prime[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%Prime[j]==<span class="number">0</span>) &#123;</span><br><span class="line">Phi[i*Prime[j]]=Phi[i]*Prime[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Phi[i*Prime[j]]=Phi[i]*Phi[Prime[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)Phi[i]=(Phi[i]+Phi[i<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,LL p,LL v)</span> </span>&#123;</span><br><span class="line">Hash[x].push_back(mp(p,v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Cal</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=limit)<span class="keyword">return</span> Phi[n];</span><br><span class="line"><span class="keyword">for</span>(pii x:Hash[n%hashmod])<span class="keyword">if</span>(x.first==n)<span class="keyword">return</span> x.second;</span><br><span class="line">LL next,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(LL i=<span class="number">2</span>; i&lt;=n; i=next+<span class="number">1</span>) &#123;</span><br><span class="line">next=n/(n/i);</span><br><span class="line">ans=(ans+(next-i+<span class="number">1</span>)%mod*Cal(n/i)%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">ans=(n%mod*(n%mod+<span class="number">1</span>)%mod*inv2%mod-ans+mod)%mod;</span><br><span class="line">Add(n%hashmod,n,ans);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">g</span><span class="params">(LL x)</span> </span>&#123;<span class="keyword">return</span> x*(x+<span class="number">1</span>)%mod*(<span class="number">2</span>*x+<span class="number">1</span>)%mod*inv6%mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Quick_Pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">LL sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>,a=a*a%mod)<span class="keyword">if</span>(b&amp;<span class="number">1</span>)sum=sum*a%mod;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">mod=Get_Int();</span><br><span class="line">inv2=(mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">inv6=Quick_Pow(<span class="number">6</span>,mod<span class="number">-2</span>);</span><br><span class="line">Table(min(n,limit));</span><br><span class="line">LL next=<span class="number">1</span>,ans=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i=next+<span class="number">1</span>) &#123;</span><br><span class="line">next=n/(n/i);</span><br><span class="line">LL now=Cal(next);</span><br><span class="line">ans=(ans+(now-last+mod)%mod*g(n/i)%mod)%mod;</span><br><span class="line">last=now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-棋技哥"><a href="#E-棋技哥" class="headerlink" title="E. 棋技哥"></a>E. 棋技哥</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>火山哥和鸡老八在下棋。<br>这张棋盘是$n\times m$的。每一个格子要么是黑色的，要么是白色的。<br>两个人轮流进行操作。火山哥先手。每一次可以选择一个黑色的格子，以这个格子为右下角，棋盘左上角为左上角，将这个矩阵的所有格子的颜色由黑变成白，由白变成黑。如果找不到一个黑色的格子，那么那个人就输了。<br>现在两个人都想让火山哥赢，请问谁能赢呢。  </p></blockquote><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>注意到一个性质，每人每次操作时，总会使左上角的格子反色。<br>那么考虑，如果火山哥先手时，左上角格子是黑色，那么火山哥操作后左上角格子变白，如果游戏还未结束，那么轮到火山哥操作时，左上角的格子还是黑色。<br>由于游戏一定会结束，而在火山哥状态时游戏必然不结束，故火山哥先手左上角格子是黑色时，火山哥必胜（和谁想谁赢一点关系都没有）。<br>如果火山哥先手时，左上角格子是白色，那么两者恰好相反，火山哥必败。  </p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>来自cyy的奥利给代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> mt[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span> (T --) &#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;mt[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mt[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">'1'</span>) <span class="built_in">printf</span>(<span class="string">"call\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"aoligei\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="F-社团管理"><a href="#F-社团管理" class="headerlink" title="F. 社团管理"></a>F. 社团管理</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>火山哥管理着一个$n$个人的社团。<br>有一天，这$n$个人要外出执行$k$个任务。这$n$个人从左到右站成了一排，其中第$i$个人支持$a_i$当老大。为了方便管理，火山哥决定把这$n$个人分成恰好$k$段(每段非空)分别执行各自的任务。<br>但是为了社团平衡，火山哥决定要让执行同一任务且$a_i$相同的二元组$(i,j)$尽量少，即假设在第$i$段里支持第$j$个人的个数是$c(i,j)$，那么火山哥就需要最小化</p><script type="math/tex; mode=display">\sum_{i=1}^k\sum_j\begin{pmatrix}c(i,j) \\ 2\end{pmatrix}</script><p>请你输出这个最小值。</p></blockquote><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>cf原题，868F。<br>dp方程很好写，但是状态转移的代价函数无法处理。<br>不过这道题有决策单调性，证明参见<a href="https://blog.csdn.net/u012602144/article/details/78307801" target="_blank" rel="noopener">这里</a>。  </p><script type="math/tex; mode=display">f(i,j)=f(i-1,k)+cost(k+1,j)</script><p>考虑用分治进行决策单调性的转移。<br>设$Solve(k,L,R,l,r)$表示用$f(k-1,l\sim r)$为决策转移求出$f(k,L\sim R)$。<br>每次暴力求出$f(k,mid=\frac{L+R}2)$，得到最优决策点$id$，递归$Solve(k,L,mid-1,l,id)$和$Solve(k,mid+1,R,id,r)$。  </p><p>怎么计算$cost$函数呢？这里就体现出来了用分治实现决策单调性的优越性，可以用莫队的方式暴力统计，每次指针移动到对应区间即可。  </p><p>每次$Solve$时枚举次数上界是$O(r-l+1)$，而统计指针的移动次数显然是关于它线性的。<br>那么时间复杂度是$O(nk\log n)$，至于$l,r$区间每一层会出现的一个重复点时间影响可以忽略不计。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L,R,a[maxn];</span><br><span class="line">LL cost,f[<span class="number">25</span>][maxn],cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Move</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(L&lt;left)cost-=--cnt[a[L++]];</span><br><span class="line"><span class="keyword">while</span>(L&gt;left)cost+=cnt[a[--L]]++;</span><br><span class="line"><span class="keyword">while</span>(R&lt;right)cost+=cnt[a[++R]]++;</span><br><span class="line"><span class="keyword">while</span>(R&gt;right)cost-=--cnt[a[R--]];</span><br><span class="line"><span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span> </span>&#123;<span class="keyword">return</span> f[k<span class="number">-1</span>][from]+Move(from+<span class="number">1</span>,to);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Left&gt;Right)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid=(Left+Right)&gt;&gt;<span class="number">1</span>,id=left;</span><br><span class="line">f[k][mid]=Cal(k,left,mid);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=left+<span class="number">1</span>; i&lt;=min(mid<span class="number">-1</span>,right); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp=Cal(k,i,mid);</span><br><span class="line"><span class="keyword">if</span>(tmp&lt;=f[k][mid]) &#123;f[k][mid]=tmp;id=i;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Solve(k,Left,mid<span class="number">-1</span>,left,id);</span><br><span class="line">Solve(k,mid+<span class="number">1</span>,Right,id,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">k=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">a[i]=Get_Int();</span><br><span class="line">f[<span class="number">1</span>][i]=f[<span class="number">1</span>][i<span class="number">-1</span>]+cnt[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=k; i++) &#123;</span><br><span class="line">fill(cnt+<span class="number">1</span>,cnt+n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">L=R=<span class="number">1</span>;</span><br><span class="line">cnt[a[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">Solve(i,<span class="number">1</span>,n,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[k][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-火山哥周游世界"><a href="#G-火山哥周游世界" class="headerlink" title="G. 火山哥周游世界"></a>G. 火山哥周游世界</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>在赌场打了一晚德扑的火山哥靠着把把All in的精湛技巧赚的盆满钵满，所以他决定拿这笔钱来周游世界。<br>世界上一共有$n$个国家，标号从$1\sim n$。他们由$n−1$条边连接着，经过每条边都有一定的时间花费。任意两个国家之间两两可达。<br>火山哥一共决定去$K$个国家。现在他想要知道:如果他从第$i$个国家出发，经过这$K$个国家的最短时间是多少？(请注意他可以在任意一个国家停下)</p></blockquote><h3 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h3><p>答案=欧拉环游序-最长链<br>这两者显然都可以用换根DP维护，所以时间复杂度$O(n)$。<br>可以建虚树做，复杂度多个$log$。  </p><p>需要注意的是，有可能换根会换到不在最佳环游序上的点，这样环游长度会变化。  </p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to;</span><br><span class="line">LL dist;</span><br><span class="line">Edge(<span class="keyword">int</span> x=<span class="number">0</span>,<span class="keyword">int</span> y=<span class="number">0</span>,LL v=<span class="number">0</span>):from(x),to(y),dist(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges[maxn];</span><br><span class="line"><span class="keyword">int</span> n,k,Mark[maxn],From[maxn];</span><br><span class="line">LL Size[maxn],Dist[maxn],Long[maxn],Sec[maxn],Ans[maxn],f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">Size[Now]=Mark[Now];</span><br><span class="line"><span class="keyword">for</span>(Edge &amp;e:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">int</span> Next=e.to;</span><br><span class="line"><span class="keyword">if</span>(Next==fa)<span class="keyword">continue</span>;</span><br><span class="line">Dfs(Next,Now);</span><br><span class="line">Size[Now]+=Size[Next];</span><br><span class="line"><span class="keyword">if</span>(Size[Next]) &#123;</span><br><span class="line"><span class="keyword">if</span>(Long[Next]+e.dist&gt;Long[Now]) &#123;</span><br><span class="line">Sec[Now]=Long[Now];</span><br><span class="line">Long[Now]=Long[Next]+e.dist;</span><br><span class="line">From[Now]=Next;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(Long[Next]+e.dist&gt;Sec[Now])Sec[Now]=Long[Next]+e.dist;</span><br><span class="line">Dist[Now]+=Dist[Next]+<span class="number">2</span>*e.dist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreeDp</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> fa,LL up)</span> </span>&#123;</span><br><span class="line">f[Now]=max(Long[Now],up);</span><br><span class="line"><span class="keyword">for</span>(Edge &amp;e:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">int</span> Next=e.to;</span><br><span class="line"><span class="keyword">if</span>(Next==fa)<span class="keyword">continue</span>;</span><br><span class="line">Ans[Next]=Ans[Now]+((Size[Next]==<span class="number">0</span>)?<span class="number">2</span>*e.dist:<span class="number">0</span>);</span><br><span class="line">LL tmp=k-Size[Next]?up+e.dist:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(From[Now]==Next&amp;&amp;Sec[Now])tmp=max(tmp,Sec[Now]+e.dist);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(From[Now]!=Next&amp;&amp;Long[Now])tmp=max(tmp,Long[Now]+e.dist);</span><br><span class="line">TreeDp(Next,Now,tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span> </span>&#123;edges[x].push_back(Edge(x,y,v));&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">k=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),y=Get_Int(),v=Get_Int();</span><br><span class="line">AddEdge(x,y,v);</span><br><span class="line">AddEdge(y,x,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++)Mark[Get_Int()]=<span class="number">1</span>;</span><br><span class="line">Dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">Ans[<span class="number">1</span>]=Dist[<span class="number">1</span>];</span><br><span class="line">TreeDp(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans[i]-f[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-火山哥的序列"><a href="#H-火山哥的序列" class="headerlink" title="H. 火山哥的序列"></a>H. 火山哥的序列</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>火山哥有一个长度为$n$的序列$a$。序列里的数互不相同。<br>现在他定义$g(x,y)$为序列删去了第$x$个到第$y$个元素之后最大的$\gcd$值，即为  </p><script type="math/tex; mode=display">\displaystyle \max_{i,j \in [1,x) \cup (y,n],i\not= j} \gcd(a_i,a_j)</script><p>特别地，当序列被删到只剩下一个元素时，$g(x,y)=0$。<br>现在他想要知道$\displaystyle \sum_{i=1}^n \sum_{j=i}^n g(i,j)$  </p></blockquote><h3 id="题目分析-7"><a href="#题目分析-7" class="headerlink" title="题目分析"></a>题目分析</h3><p>还没搞明白，搞明白了回来补。  </p><h2 id="I-N门问题"><a href="#I-N门问题" class="headerlink" title="I. N门问题"></a>I. N门问题</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>火山哥参加了一个抽(猜)奖活动。<br>现在他的面前有$N(N\geq 2)$扇门，只有$1$扇门的背后有大奖，其余的门后都是空的。活动有一个主持人，他事先知道哪扇门后有大奖。每次当火山哥选择一扇门(不打开)后，主持人会从剩下的没有打开的、且不是对应大奖的门中，等概率地随机挑选一扇门打开，然后再给火山哥一次选择门的机会(火山哥可以选择保持之前的选择不变或者换成任意一扇他想要的门)，直到只剩两扇门为止，此时火山哥的选择就是他的最终选择。<br>火山哥想获得大奖，但他不知道任何信息，于是他决定每次在”所有可选的门”中挑选一个”在他的视角中背后有奖的概率最大”的门，如果这样的门有多个，则他会在其中等概率地随机挑选一个。(显然第一次选门时，他的视角中每扇门背后有大奖的概率都是$\frac{1}{N}$，所以他会随机在$N$扇门中选一扇)<br>换言之，火山哥选门的过程可以抽象为以下过程：  </p><ul><li>while(剩余门的数量 &gt;= 2):  </li><li>$\quad$火山哥按照上文所述选定一扇门，不打开</li><li>$\quad$if(剩余门的数量 == 2):</li><li>$\quad\quad$这扇门是火山哥的最终选择; break;</li><li>$\quad$主持人按照上文所述打开一扇门(同时意味着剩余门的数量-1)</li><li>$\quad$火山哥重新计算每扇门后有奖的概率  </li></ul><p>现在活动主办方安排你作为主持人，并要求你埋伏火山哥一手，换言之你每次可以在剩下的门中(除了火山哥选择的和最终大奖的门之外)主动选择某扇门(而非随机地)来打开，目的就是让火山哥最终选择到大奖门的概率最小。现在给你$N$，求这个最小的概率。<br>注意: 火山哥并不知道你的存在。换言之，他依然认为主持人是正常的而不会去揣测他的用意。</p></blockquote><h3 id="题目分析-8"><a href="#题目分析-8" class="headerlink" title="题目分析"></a>题目分析</h3><p>首先，这道题的这个模型肯定要进行转化，下面是官方题解的转化过程：  </p><blockquote><p>贪心地让每一步中正确的门的概率最小、每次打开概率最大的门、每次打开概率最小的门，这些策略都是错误的，枚举一些N=5、6的情况大概可以感受到。<br>事实上，通过归纳法可以证明，无论打开了哪扇门，A选择的那扇门在门打开之后都会变成全场唯一概率最小的门。<br>通过这一结论我们可以把问题转成类似一个序列操作问题：<br>一开始有N个球一起放在序列头，有一个是正确球。<br>每次A从序列头的所有球中随机抽一个，然后B可以丢弃剩下球中不是正确球的任意一个，然后A把他抽的球单独地放在序列末尾。<br>可以感受到，当N足够大时，B一定可以通过控奇偶性让A必败。(这也可以坑到只观察序列前三项而认为序列单调递增趋于1的选手)</p></blockquote><p>首先，本人认为题解中提到的“A选择的那扇门在门打开之后都会变成全场唯一概率最小的门”并不成立，题解也没有给出证明过程，但题解似乎把单步概率和全局概率混淆了？<br>所以我对这个结论保留质疑态度，如果有读者会证明请教教我（  </p><p>但是转化后的问题就很好做了。<br>设$f(i,j,k)$表示有$i$个球，第一列有$j$个球，正确球（黑球）在第$k$列，考虑它的转移。  </p><h4 id="f-i-j-1-的转移"><a href="#f-i-j-1-的转移" class="headerlink" title="$f(i,j,1)$的转移"></a>$f(i,j,1)$的转移</h4><img src="/wannafly-camp-day3/2.svg">  <script type="math/tex; mode=display">\begin{aligned}f(i,j,1)&\rightarrow f(i-1,j-2,i-j+2)\quad&(j\ge2)\quad&\text{火山哥选择黑球，主持人删掉第一列的白球} \\&\rightarrow f(i-1,j-1,i-j+1)\quad&(i\gt j)\quad&\text{火山哥选择黑球，主持人删掉后面的白球} \\&\rightarrow f(i-1,j-2,1)\quad&(j\gt2)\quad&\text{火山哥选择白球，主持人删掉第一列的白球} \\&\rightarrow f(i-1,j-1,1)\quad&(i\gt j)\quad&\text{火山哥选择白球，主持人删掉后面的白球}\end{aligned}</script><p>需要注意的是，因为火山哥是随机选取，所以最终$f(i,j,1)$应该是火山哥选择黑球获得的概率$+$火山哥选择白球获得的概率。而主持人删球是主持人选取的，故火山哥选择黑/白球的时候概率应该取$\min$。  </p><h4 id="f-i-j-k-的转移"><a href="#f-i-j-k-的转移" class="headerlink" title="$f(i,j,k)$的转移"></a>$f(i,j,k)$的转移</h4><img src="/wannafly-camp-day3/3.svg">  <script type="math/tex; mode=display">\begin{aligned}f(i,j,k)&\rightarrow f(i-1,j-2,k)\quad&(j\ge2)\quad&\text{主持人删掉第一列的白球} \\f(i,j,k)&\rightarrow f(i-1,j-1,k-1)\quad&(k\gt2)\quad&\text{主持人删掉黑球前面的白球，但不能是第一列} \\f(i,j,k)&\rightarrow f(i-1,j-1,k)\quad&(k\lt i-j+1)\quad&\text{主持人删掉黑球后面的白球}\end{aligned}</script><p>火山哥只有一种选择，所以这里都应该取$\min$</p><h4 id="f-i-1-k-的转移"><a href="#f-i-1-k-的转移" class="headerlink" title="$f(i,1,k)$的转移"></a>$f(i,1,k)$的转移</h4><img src="/wannafly-camp-day3/4.svg">  <script type="math/tex; mode=display">\begin{aligned}f(i,1,k)&\rightarrow f(i-1,1,k-2)\quad&(k\gt2)\quad&\text{主持人删掉黑球前面的白球} \\f(i,1,k)&\rightarrow f(i-1,1,k-1)\quad&(k\lt i)\quad&\text{主持人删掉黑球后面的白球}\end{aligned}</script><h4 id="f-i-1-1-的转移"><a href="#f-i-1-1-的转移" class="headerlink" title="$f(i,1,1)$的转移"></a>$f(i,1,1)$的转移</h4><img src="/wannafly-camp-day3/5.svg">  <p>只有一种转移：</p><script type="math/tex; mode=display">f(i,1,k)\rightarrow f(i-1,1,i-1)</script><p>动规告诉我们，当$n\gt10$的时候，火山哥获胜的概率为$0$，也就是说火山哥必败。<br>注意求$n$需要用<a href="/chinese-remainder-theorem-notes/">扩展中国剩余定理</a>。  </p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exgcd</span><span class="params">(LL a,LL b,LL &amp;d,LL &amp;x,LL &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b)d=a,x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> Exgcd(b,a%b,d,y,x),y-=(a/b)*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Quick_Mul</span><span class="params">(LL a,LL b,LL p)</span> </span>&#123;</span><br><span class="line">LL sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>,a=(a&lt;&lt;<span class="number">1</span>)%p)<span class="keyword">if</span>(b&amp;<span class="number">1</span>)sum=(sum+a)%p;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Excrt</span><span class="params">(<span class="keyword">int</span> n,LL *r,LL *m)</span> </span>&#123;</span><br><span class="line">LL M=m[<span class="number">1</span>],ans=r[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123; <span class="comment">//Mx_1+m_ix_2=a_i-ans</span></span><br><span class="line">LL a=M,b=m[i],x,y,c=(r[i]-ans%m[i]+m[i])%m[i],gcd;</span><br><span class="line">Exgcd(a,b,gcd,x,y);</span><br><span class="line"><span class="keyword">if</span>(c%gcd)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">x=Quick_Mul(x,c/gcd,b/gcd);</span><br><span class="line">ans+=x*M;</span><br><span class="line">M=M/gcd*b;</span><br><span class="line">ans=(ans%M+M)%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL n,m,a[maxm],b[maxm];</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">15</span>][<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dp</span><span class="params">(LL x,LL y,LL z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(z!=<span class="number">1</span>)<span class="keyword">return</span> Dp(x,<span class="number">1</span>,z<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> Dp(x,<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">1</span>)<span class="keyword">return</span> z==<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f[x][y][z]!=<span class="number">-1</span>)<span class="keyword">return</span> f[x][y][z];</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(z==<span class="number">1</span>)<span class="keyword">return</span> f[x][y][z]=Dp(x<span class="number">-1</span>,<span class="number">1</span>,x<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(z==<span class="number">2</span>)<span class="keyword">return</span> f[x][y][z]=Dp(x<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(z==x)<span class="keyword">return</span> f[x][y][z]=Dp(x<span class="number">-1</span>,<span class="number">1</span>,z<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> f[x][y][z]=min(Dp(x<span class="number">-1</span>,<span class="number">1</span>,z<span class="number">-1</span>),Dp(x<span class="number">-1</span>,<span class="number">1</span>,z<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(z==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">double</span> black=<span class="number">1</span>,white=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y&gt;=<span class="number">2</span>)black=Dp(x<span class="number">-1</span>,y<span class="number">-2</span>,x-y+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(x&gt;y)black=min(black,Dp(x<span class="number">-1</span>,y<span class="number">-1</span>,x-y+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span>(y&gt;<span class="number">2</span>)white=Dp(x<span class="number">-1</span>,y<span class="number">-2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(x&gt;y)white=min(white,Dp(x<span class="number">-1</span>,y<span class="number">-1</span>,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> f[x][y][z]=black*(<span class="number">1.0</span>/y)+white*((y<span class="number">-1.0</span>)/y);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">f[x][y][z]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y&gt;=<span class="number">2</span>)f[x][y][z]=Dp(x<span class="number">-1</span>,y<span class="number">-2</span>,z);</span><br><span class="line"><span class="keyword">if</span>(z&gt;<span class="number">2</span>)f[x][y][z]=min(f[x][y][z],Dp(x<span class="number">-1</span>,y<span class="number">-1</span>,z<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">if</span>(z&lt;x-y+<span class="number">1</span>)f[x][y][z]=min(f[x][y][z],Dp(x<span class="number">-1</span>,y<span class="number">-1</span>,z));</span><br><span class="line"><span class="keyword">return</span> f[x][y][z];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">a[i]=Get_Int();</span><br><span class="line">b[i]=Get_Int();</span><br><span class="line">&#125;</span><br><span class="line">n=Excrt(m,a,b);</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="built_in">puts</span>(<span class="string">"error"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n&gt;<span class="number">10</span>)<span class="built_in">puts</span>(<span class="string">"0.000000"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=n; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=n; k++)f[i][j][k]=<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>,Dp(n,n,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-简单字符串"><a href="#J-简单字符串" class="headerlink" title="J. 简单字符串"></a>J. 简单字符串</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>对于字符串$s$和整数$k$，定义$f(s,k)$为，将$s$划分为至多$k$段$u_1,u_2,\ldots u_l$，最小化$\max_{1\leq i\leq l} u_i$(比较按照字典序)，求最小化的结果。<br>现在我们有一个字符串$S$，$q$次询问$f(s[l_i\ldots |s|],k_i)$的值，对于每个询问输出$a_i,b_i$表示$f(s[l_i\ldots |s|], k_i)=S[a_i\ldots b_i]$，其中要求$S[a_i \ldots b_i]$在一个可能的划分中。<br>如果有多个，输出$a_i$最小的解，要求$a_i \geq l_i$。  </p></blockquote><h3 id="题目分析-9"><a href="#题目分析-9" class="headerlink" title="题目分析"></a>题目分析</h3><p>需要用到lyndon分解，溜了溜了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文章施工中……&lt;br&gt;进度&lt;code&gt;[===================&amp;gt;] 10/10 100%&lt;/code&gt;&lt;br&gt;施工完成。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://blog.bill.moe/categories/ACM/"/>
    
    
      <category term="动态规划" scheme="https://blog.bill.moe/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="https://blog.bill.moe/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="莫比乌斯反演" scheme="https://blog.bill.moe/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="状态压缩" scheme="https://blog.bill.moe/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="比赛酱油记" scheme="https://blog.bill.moe/tags/%E6%AF%94%E8%B5%9B%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
      <category term="分治" scheme="https://blog.bill.moe/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="决策单调性" scheme="https://blog.bill.moe/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
      <category term="中国剩余定理" scheme="https://blog.bill.moe/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
      <category term="点分治" scheme="https://blog.bill.moe/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>「通知」博客搬迁到Github Pages</title>
    <link href="https://blog.bill.moe/hello-github/"/>
    <id>https://blog.bill.moe/hello-github/</id>
    <published>2020-01-16T04:19:27.000Z</published>
    <updated>2020-07-12T13:40:37.680Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于zz的Coding Pages最近又加入了腾讯的zz TMS审核系统，这导致我的博客全篇被审核拦截（违规页面参数：综合）。<br>这综合是个什么玩意儿，Coding的客服表示它们也不清楚，用的是第三方服务。<br>于是我决定搬迁了，之前就发现Coding很不好用，本来以前是认为Coding Pages的结点会比较快，这次终于给了我一个最大的搬迁理由。<br>接下来博客会搬迁到Github Pages，当你们看到这篇文章时，博客已经搬迁好了了。<br>其实本来打算搬迁到阿里云，但是因为moe后缀域名没法备份，主机都买好了结果放弃了。<br>原来的Coding Pages下的博客仍然可以用<a href="https://coding.bill.moe/" target="_blank" rel="noopener">https://coding.bill.moe/</a> 访问。（已失效）<br>博客接下来会继续更新的，谢谢大家一直以来的支持。  </p><p>updated 2020/03/22：Coding Pages未实名认证即将停止运行，因此撤下对Coding的DNS解析，同时本站将同步托管至Zeit Now以获得更好的百度收录。（已完成迁移）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="博客迁移" scheme="https://blog.bill.moe/categories/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
    
    
      <category term="hello world" scheme="https://blog.bill.moe/tags/hello-world/"/>
    
  </entry>
  
  <entry>
    <title>2020 CCPC wannafly 冬令营 Day2 游记+解题报告</title>
    <link href="https://blog.bill.moe/wannafly-camp-day2/"/>
    <id>https://blog.bill.moe/wannafly-camp-day2/</id>
    <published>2020-01-14T04:28:08.000Z</published>
    <updated>2020-07-12T13:40:37.783Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>游记及总结在<a href="https://www.zhihu.com/answer/973191974" target="_blank" rel="noopener">逼乎</a>。</p><p>全部补完~！</p><a id="more"></a><h2 id="A-托米的字符串"><a href="#A-托米的字符串" class="headerlink" title="A. 托米的字符串"></a>A. 托米的字符串</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>托米有一个字符串，他经常拿出来玩。这天在英语课上，他学习了元音字母$a,e,i,o,u$以及半元音$y$。“这些字母是非常重要的！”，托米这样想着，“那么我如果随机取一个子串，里面元音占比期望会有多大呢？”<br>于是，请你求出对于托米的字符串，随机取一个子串，元音$(a,e,i,o,u,y)$字母占子串长度比的期望是多少。</p></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>只要统计出$f(l,r)$表示$[l,r]$区间内元音字母的个数，那么$\frac{f(l,r)}{r-l+1}$就是这段区间对答案长度比的贡献，统计出所有区间的贡献，除以$\frac{n(n+1)}2$就是答案。<br>贡献可以用前缀和简单的统计。  </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isvowel</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;<span class="keyword">return</span> x==<span class="string">'a'</span>||x==<span class="string">'e'</span>||x==<span class="string">'i'</span>||x==<span class="string">'o'</span>||x==<span class="string">'u'</span>||x==<span class="string">'y'</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)sum[i]=sum[i<span class="number">-1</span>]+isvowel(s[i]);</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">cnt+=sum[n-i+<span class="number">1</span>]-sum[i<span class="number">-1</span>];</span><br><span class="line">ans+=cnt/i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>,ans/(<span class="number">1l</span>l*n*(n+<span class="number">1</span>)/<span class="number">2</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-萨博的方程式"><a href="#B-萨博的方程式" class="headerlink" title="B. 萨博的方程式"></a>B. 萨博的方程式</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>萨博有个方程式：  </p><script type="math/tex; mode=display">x_1\oplus x_2\oplus x_3\oplus\cdots\oplus x_n=k</script><p>其中$\oplus$指代位运算中的异或符号。<br>萨博同时还对每个未知数限制了范围为$0\le x_i\le m_i$，希望你计算出解的个数，最终答案对$10^9+7$取模后输出。</p></blockquote><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>又一道想不到的题。<br>考场上觉得可能是高斯消元或者线性基搞一波，然后发现不可行，于是就放掉了。<br>考完评价结果是一道数位Dp，这种数位Dp是一种和以往不同的特殊数位Dp，之后在yk的点拨下A掉了。  </p><p>我们将$m_i$都转化为二进制表示，从高位到低位逐位考虑。<br>假设当前二进制位是$bit$，提取出所有$bit$位为$1$的$m_i$，考虑它们$x_i$的取值。  </p><p>假如所有当前的$x_i$的$bit$位都取$1$，考虑$bit$位是否满足$k$的限制，倘若满足，那么转化为考虑$bit-1$位的情形，否则方案数为$0$。  </p><p>现在来考虑不全取$1$的情况。<br>假设对于某个$x_i$，它在$bit$位不选择$1$，于是$x_i$的高位限制就被取消了，那么无论其他解的$0~bit-1$位怎么取值，总有一种$x_i$的取值能使题面的等式成立，这样我们可以通过另外一次Dp来计算出这一位的贡献。  </p><p>设$f(i,j)$为$bit$位为$1$的前$i$个$x$，$x$的高位确定了$j$个$1$的方案数。  </p><script type="math/tex; mode=display">f(i,j)=f(i-1,j-1)\times lim[i]_{(0,bit-1)}+f(i-1,j)\times2^{bit}</script><p>其中$lim[i]_{(0,bit-1)}$表示$lim[i]$的二进制表示中取第$0$位到$bit-1$的值。<br>状态转移方程的解释如下：  </p><ul><li>如果$x_i$第$bit$位取值为$0$，那么高位限制解除，$x_i$有$2^{bit}$种选择。  </li><li>如果$x_i$第$bit$位取值为$1$，那么高位限制没有解除，$x_i$只有$lim[i]_{(0,bit-1)}$种选择。  </li></ul><p>需要注意的是，对于那些$lim[i]$的$bit$位不为$1$的$x_i$而言，他们对本次答案的贡献就是$lim[i]$，累乘即可。在统计答案的时候，由于不全取$1$，而我们尚未确定究竟是哪一个$1$不取，在Dp的时候多算了一次$2^{bit}$的贡献，除去即可，详见代码。  </p><p>这道题和一般的数位Dp的区别在于，一般的数位Dp只考虑某一个数在某一位是否有高位限制，而本题将一些数打包一起考虑。  </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">LL f[maxn][maxn],lim[maxn],a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Quick_Pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">LL sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>,a=a*a%mod)<span class="keyword">if</span>(b&amp;<span class="number">1</span>)sum=sum*a%mod;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Dp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>||y&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(~f[x][y])<span class="keyword">return</span> f[x][y];</span><br><span class="line"><span class="keyword">return</span> f[x][y]=(Dp(x<span class="number">-1</span>,y,bit)*(<span class="number">1</span>&lt;&lt;bit)%mod+Dp(x<span class="number">-1</span>,y<span class="number">-1</span>,bit)*(a[x]+<span class="number">1</span>)%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bit&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">LL others=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(lim[i]&gt;&gt;bit&amp;<span class="number">1</span>) &#123;lim[i]^=<span class="number">1</span>&lt;&lt;bit;a[++cnt]=lim[i];&#125;</span><br><span class="line"><span class="keyword">else</span> others=others*(lim[i]+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=cnt; j++)f[i][j]=<span class="number">-1</span>;</span><br><span class="line">LL inv=Quick_Pow(<span class="number">1</span>&lt;&lt;bit,mod<span class="number">-2</span>),ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; i++)<span class="keyword">if</span>((m&gt;&gt;bit&amp;<span class="number">1</span>)==(i&amp;<span class="number">1</span>))ans=(ans+Dp(cnt,i,bit)*others%mod*inv%mod)%mod; <span class="comment">//不全选1</span></span><br><span class="line"><span class="keyword">if</span>((m&gt;&gt;bit&amp;<span class="number">1</span>)==(cnt&amp;<span class="number">1</span>))<span class="keyword">return</span> (ans+Cal(bit<span class="number">-1</span>))%mod; <span class="comment">//全选1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ans; <span class="comment">//不能全选1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)lim[i]=Get_Int();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Cal(<span class="number">30</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-萨博的方程式"><a href="#C-萨博的方程式" class="headerlink" title="C. 萨博的方程式"></a>C. 萨博的方程式</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>纳新一百和乱得尬得在玩取石子的游戏。他们一共有$N$堆石子，第$i$堆有$a_i$颗石子（若$a_i=0$则表示这是一堆空石子堆）。<br>纳新一百和乱得尬得轮流进行游戏，纳新一百先手。轮到某个人时，他需要选择一堆非空的石子堆，并拿走任意数量的石子。如果不存在一堆非空的石子堆，则轮到的人输掉游戏。纳新一百想要知道，他的第一轮操作有多少种不同的取法能够保证他最后取得游戏的胜利。假设两个人都是用最优策略在玩游戏，两种操作方式视为不同当且仅当两种方式选取的石子堆的序号不同或取走的石子数量不同。<br>为了增加趣味性，纳新一百和乱得尬得决定对前$i$堆石子都玩一次游戏，两次游戏相互独立，也就是说，每开始一个新的游戏，石子堆都会被复原。<br>现在，纳新一百想要知道每一次游戏中，他能够取得胜利的第一轮操作方案数。</p></blockquote><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>签到题。<br>众所周知第$i$堆石子的SG函数$SG(a_i)=a_i$。<br>所以问题转化为对于前$i$堆石子的异或和$x$，有多少堆石子满足$a_i\gt x\oplus a_i$，因为只要满足这个条件，就能拿走一些石子使其石子数变为$x\oplus a_i$，从而使异或和变为$0$使得后手必输。<br>可以证明，若异或和$x$的最高有效位为$bit$，那么所有$bit$位为$1$的$a_i$都满足条件，而为$0$的不满足条件。  </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>来自cyy的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">64</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> xorsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">xorsum ^= a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">63</span>;j&gt;=<span class="number">0</span>;j--) <span class="keyword">if</span> ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) cnt[j] ++;</span><br><span class="line"><span class="keyword">if</span> (xorsum == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> hb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">63</span>;j&gt;=<span class="number">0</span>;j--) <span class="keyword">if</span> ((xorsum &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">hb = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt[hb]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="D-卡拉巴什的字符串"><a href="#D-卡拉巴什的字符串" class="headerlink" title="D. 卡拉巴什的字符串"></a>D. 卡拉巴什的字符串</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>卡拉巴什是字符串大师，这天他闲着无聊，又造了个字符串问题。<br>给定一个长度为$N$字符串$S$，定义后缀$i$为从第$i$个位置开始的后缀，即$s_{i}s_{i+1}\cdots s_{n}$，定义$lcp(i,j)$为后缀$i$和后缀$j$的最长公共前缀。<br>卡拉巴什想要知道，每次他给出一组$i,j$，你能否快速告诉他$lcp(i,j)$。<br>卡拉巴什的好朋友葫芦是字符串宗师，他认为这个题太无聊，于是他想了另一个问题，假设有一个集合$lcp(i,j) | 1\leq i &lt; j\leq N$，他想知道这个集合的$MEX$值是多少。一个集合的$MEX$值为最小的没有出现在集合中的非负整数。<br>这个问题对卡拉巴什来说太容易了，于是葫芦想知道，对于字符串的每一个前缀，对应的集合的$MEX$值是多少。</p></blockquote><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>考试时没认真想，考完了想想还是不难的。。。</p><p>考虑用后缀自动机求两个后缀的LCP，即它们在后缀树上$lca$结点的$Max$值，所以两两后缀的$LCP$的集合就是后缀自动机上非叶子结点的$Max$值的集合。  </p><ol><li>方法一：考虑一个个字母加入时动态构建后缀自动机，每当一个节点有儿子结点，那这个结点就能成为两个不同后缀的$lca$，就在布尔数组里将它的$Max$标记为$1$。每加入一个字母都暴力维护$MEX$的值，均摊时间复杂度$O(n)$</li><li>方法二：考虑两个后缀的LCP值加入为$x$，同时删掉第一个字母，LCP就变$x-1$，所以$1$到$x$都存在，所以答案就是的最大值+1  </li></ol><p>注意特判单字母的字符串是没有为$0$的$LCP$的。在方法一中，体现为后缀树的根结点在只有一个儿子的时候不能成为$lca$，因为根结点不代表一个后缀。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>方法二<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>,maxc=<span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Suffix_Automaton</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt,root,last,f;</span><br><span class="line"><span class="keyword">int</span> child[maxn&lt;&lt;<span class="number">1</span>][maxc],next[maxn&lt;&lt;<span class="number">1</span>],Max[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line">Suffix_Automaton() &#123;init();&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;cnt=f=<span class="number">0</span>;root=last=newnode(<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">cnt++;</span><br><span class="line">next[cnt]=<span class="number">0</span>;</span><br><span class="line">Max[cnt]=val;</span><br><span class="line">fill(child[cnt],child[cnt]+maxc,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=last,u=newnode(Max[last]+<span class="number">1</span>);</span><br><span class="line">last=u;</span><br><span class="line"><span class="keyword">for</span>(; p&amp;&amp;!child[p][data]; p=next[p])child[p][data]=u;</span><br><span class="line"><span class="keyword">if</span>(!p)next[u]=root;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> old=child[p][data];</span><br><span class="line"><span class="keyword">if</span>(Max[old]==Max[p]+<span class="number">1</span>)next[u]=old;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> New=newnode(Max[p]+<span class="number">1</span>);</span><br><span class="line">copy(child[old],child[old]+maxc,child[New]);</span><br><span class="line">next[New]=next[old];</span><br><span class="line">next[u]=next[old]=New;</span><br><span class="line"><span class="keyword">for</span>(; child[p][data]==old; p=next[p])child[p][data]=New;</span><br><span class="line">&#125;</span><br><span class="line">f=max(f,Max[next[u]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; sam;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">sam.init();</span><br><span class="line"><span class="keyword">char</span> last=s[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:s) &#123;</span><br><span class="line">sam.insert(x-<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">if</span>(x!=last)flag=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,flag?sam.f+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="E-阔力梯的树"><a href="#E-阔力梯的树" class="headerlink" title="E. 阔力梯的树"></a>E. 阔力梯的树</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>阔力梯有一棵树，这棵树有$N$个节点，每个节点按顺序编号为$1−N$，其中，$1$号节点是根结点。<br>定义树上一个节点的“结实程度”为，将这个节点的子树中的所有的节点编号拿出来之后，按照从小到大的顺序排列，然后将相邻元素做差之后求平方和。即假设子树的节点编号排序后的序列为$a_1,a_2,a_3,\ldots,a_k$，这个节点的“结实程度”就是：</p><script type="math/tex; mode=display">\sum_{i=1}^{k-1}(a_{i+1}-a_i)^2</script><p>现在，阔力梯想要加固这棵树，但是他的资源有限，不能加固所有的节点，所以他想知道每个节点的“结实程度”是多少。</p></blockquote><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>维护一个set，那么$1$的答案很好求，换根的时候也很好处理贡献差，所以写一个换根DP就好了。<br>结果我写着写着写成了dsu on tree。<br>启发式合并一下，继承重儿子的set，暴力合并轻儿子的set，就可以了。<br>反正复杂度也是对的，所以就没管了，没想到标解也是dsu on tree。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,Size[maxn],Son[maxn];</span><br><span class="line">LL Ans[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">Size[Now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line">Dfs(Next);</span><br><span class="line">Size[Now]+=Size[Next];</span><br><span class="line"><span class="keyword">if</span>(Size[Next]&gt;Size[Son[Now]])Son[Now]=Next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> Now,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;S,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> pre=S.lower_bound(x),suc=S.upper_bound(x); <span class="comment">//用的前提是x不在set中</span></span><br><span class="line"><span class="keyword">if</span>(pre==S.begin()) &#123; <span class="comment">//set里面找不到小于x的</span></span><br><span class="line"><span class="keyword">if</span>(suc!=S.end())Ans[Now]+=<span class="number">1l</span>l*x*x+<span class="number">1l</span>l*(*suc)*(*suc)<span class="number">-1l</span>l*<span class="number">2</span>*x*(*suc);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//有前驱</span></span><br><span class="line">pre--;</span><br><span class="line"><span class="keyword">if</span>(suc!=S.end())Ans[Now]+=<span class="number">1l</span>l*<span class="number">2</span>*x*x+<span class="number">1l</span>l*<span class="number">2</span>*(*pre)*(*suc)<span class="number">-1l</span>l*<span class="number">2</span>*x*(*pre)<span class="number">-1l</span>l*<span class="number">2</span>*x*(*suc); <span class="comment">//有前驱后继</span></span><br><span class="line"><span class="keyword">else</span> Ans[Now]+=<span class="number">1l</span>l*x*x+<span class="number">1l</span>l*(*pre)*(*pre)<span class="number">-1l</span>l*<span class="number">2</span>*x*(*pre); <span class="comment">//有前驱无后继</span></span><br><span class="line">&#125;</span><br><span class="line">S.insert(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> Now,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Son[Now]) &#123;</span><br><span class="line">Dfs(Son[Now],S);</span><br><span class="line">Ans[Now]=Ans[Son[Now]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">if</span>(Next==Son[Now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">Dfs(Next,tmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:tmp)Add(Now,S,x);</span><br><span class="line">&#125;</span><br><span class="line">Add(Now,S,Now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)edges[Get_Int()].push_back(i);</span><br><span class="line">Dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">Dfs(<span class="number">1</span>,S);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-采蘑菇的克拉莉丝"><a href="#F-采蘑菇的克拉莉丝" class="headerlink" title="F. 采蘑菇的克拉莉丝"></a>F. 采蘑菇的克拉莉丝</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>克拉莉丝在玩一个采蘑菇的游戏。游戏地图是一张$N$个节点，$N-1$条边的连通无向图。一开始起点在$1$号点。<br>游戏过程中会发生两种事件：</p><ul><li>$1\ v\ x\ (1\le x\le10^5)\,$表示在编号为$v$的节点新出现了$x$个蘑菇  </li><li>$2\ v$表示克拉莉丝的起点变成了节点$v$  </li></ul><p>在每个事件之后，克拉莉丝想要知道，他收集完所有的蘑菇所需的代价。<br>蘑菇的收集规则是这样的，对于每个蘑菇，克拉莉丝要收集它，所需要的代价是这个蘑菇所在节点和起点之间的路径上最靠近起点的边的边权。在起点上的蘑菇不需要代价就能收集。</p></blockquote><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>我们有一种暴力的方法是，直接用树状数组维护子树和，然后对于每个询问，枚举“新根”的每一条边统计答案。<br>但显然，这种做法在菊花图会被卡成$nq$。<br>我们可以利用类似<a href="/tree-subdivision-for-tree-dp/">树链剖分维护动态规划</a>的思想，在询问时只处理重儿子的贡献，那么我们还差轻儿子的贡献。我们可以在修改时爬重链，把轻链的答案全部累加到重链链头的父亲处，这样我们就可以$O(1)$获得轻儿子贡献了，而爬树的复杂度是$O(\log n)$的。回答询问时将三部分相加即可。<br>时间复杂度是$O(q\log n)$</p><p>这道题考试时yk用了一种两次离线的做法A掉了，还没研究，贴份代码。  </p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,dist;</span><br><span class="line">Edge(<span class="keyword">int</span> x=<span class="number">0</span>,<span class="keyword">int</span> y=<span class="number">0</span>,<span class="keyword">int</span> v=<span class="number">0</span>):from(x),to(y),dist(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LL Size[maxn],Value[maxn],restf[maxn];</span><br><span class="line"><span class="keyword">int</span> n,step=<span class="number">0</span>,root=<span class="number">1</span>,father[maxn],Son[maxn],Top[maxn],First[maxn],Last[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">Size[Now]=<span class="number">1</span>;</span><br><span class="line">father[Now]=fa;</span><br><span class="line"><span class="keyword">for</span>(Edge &amp;e:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">int</span> Next=e.to;</span><br><span class="line"><span class="keyword">if</span>(Next==fa)<span class="keyword">continue</span>;</span><br><span class="line">Value[Next]=e.dist;</span><br><span class="line">Dfs(Next,Now);</span><br><span class="line">Size[Now]+=Size[Next];</span><br><span class="line"><span class="keyword">if</span>(Size[Next]&gt;Size[Son[Now]])Son[Now]=Next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> fa,<span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">Top[Now]=top;</span><br><span class="line">First[Now]=++step;</span><br><span class="line"><span class="keyword">if</span>(Son[Now])Dfs(Son[Now],Now,top);</span><br><span class="line"><span class="keyword">for</span>(Edge &amp;e:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">int</span> Next=e.to;</span><br><span class="line"><span class="keyword">if</span>(Next==fa||Next==Son[Now])<span class="keyword">continue</span>;</span><br><span class="line">Dfs(Next,Now,Next);</span><br><span class="line">&#125;</span><br><span class="line">Last[Now]=step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span> </span>&#123;edges[x].push_back(Edge(x,y,v));&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">LL c[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;=n; i+=lowbit(i))c[i]+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&gt;=<span class="number">1</span>; i-=lowbit(i))ans+=c[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> bit.query(Last[x])-bit.query(First[x]<span class="number">-1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),y=Get_Int(),v=Get_Int();</span><br><span class="line">AddEdge(x,y,v);</span><br><span class="line">AddEdge(y,x,v);</span><br><span class="line">&#125;</span><br><span class="line">Dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">Dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> q=Get_Int();</span><br><span class="line">LL sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(q--) &#123;</span><br><span class="line"><span class="keyword">int</span> opt=Get_Int();</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),v=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=Top[x]; i!=<span class="number">1</span>; i=Top[father[i]])restf[father[i]]+=v*Value[i];</span><br><span class="line">bit.add(First[x],v);</span><br><span class="line">sum+=v;</span><br><span class="line">&#125; <span class="keyword">else</span> root=Get_Int();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,restf[root]+Query(Son[root])*Value[Son[root]]+(sum-Query(root))*Value[root]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yk的两次离线<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) (x)*(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000007</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1</span>&lt;&lt;<span class="number">29</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> head[maxn],nex[maxn&lt;&lt;<span class="number">1</span>],to[maxn&lt;&lt;<span class="number">1</span>],e1,w[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> L[maxn],cl,R[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ++e1;nex[e1]=head[u];head[u]=e1;to[e1]=v;w[e1]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    L[u]=++cl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    R[u]=cl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> n;ll ans[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,x;</span><br><span class="line">    node(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x):l(l),r(r),x(x)&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[u].size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=g[u][i];</span><br><span class="line">        <span class="keyword">if</span>(L[u]&gt;<span class="number">1</span>) G[pos].push_back(node(<span class="number">1</span>,L[u]<span class="number">-1</span>,x));</span><br><span class="line">        <span class="keyword">if</span>(R[u]&lt;n) G[pos].push_back(node(R[u]+<span class="number">1</span>,n,x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nex[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(v,u,w[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;g[u].size();k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=g[u][k];</span><br><span class="line">            G[pos].push_back(node(L[v],R[v],w[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll sum[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        sum[o]+=y;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=m) update(o&lt;&lt;<span class="number">1</span>,l,m,x,y);</span><br><span class="line">    <span class="keyword">else</span> update(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,m+<span class="number">1</span>,r,x,y);</span><br><span class="line">    sum[o]=sum[o&lt;&lt;<span class="number">1</span>]+sum[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==ql&amp;&amp;r==qr) <span class="keyword">return</span> sum[o];</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=m&amp;&amp;qr&gt;m) <span class="keyword">return</span> query(o&lt;&lt;<span class="number">1</span>,l,m,ql,m)+query(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,m+<span class="number">1</span>,r,m+<span class="number">1</span>,qr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ql&lt;=m) <span class="keyword">return</span> query(o&lt;&lt;<span class="number">1</span>,l,m,ql,qr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,m+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=read(),v=read(),x=read();</span><br><span class="line">        addedge(u,v,x);addedge(v,u,x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> q=read(),Now=<span class="number">1</span>;</span><br><span class="line">    DFS(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt=read();</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">            G[i].push_back(node(<span class="number">0</span>,L[x],y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Now=read();</span><br><span class="line">        g[Now].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        ll tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;G[i].size();k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(G[i][k].l==<span class="number">0</span>)&#123;</span><br><span class="line">                update(<span class="number">1</span>,<span class="number">1</span>,n,G[i][k].r,G[i][k].x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tot+=G[i][k].x*query(<span class="number">1</span>,<span class="number">1</span>,n,G[i][k].l,G[i][k].r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="G-糖糖王国的道路修建"><a href="#G-糖糖王国的道路修建" class="headerlink" title="G. 糖糖王国的道路修建"></a>G. 糖糖王国的道路修建</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>质量和辉辉是一对姐妹，她们统治着糖糖王国。糖糖王国有$n+m$个城镇，可以看作是平面上的$n+m$个整点，其中$n$个属于质量，另外$m$个属于辉辉。<br>现在质量和辉辉要在各自的城镇之间修建道路，道路必须是笔直的线段。学过简单图论的小盆友都知道，只需要$n+m−2$条线段就可以让质量和辉辉的城镇各自两两相连。<br>现在就希望你能给出方案，要求在满足连通性的同时，任意两条线段都不能在城镇点以外的地方相交。如果不存在这样的方案也请判断。</p></blockquote><h3 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h3><p>太神了不会做，应该不会回来补了。<br>贴个<a href="https://ac.nowcoder.com/discuss/363450?type=101&amp;order=0&amp;pos=1&amp;page=0" target="_blank" rel="noopener">官方题解</a>在这儿吧。  </p><h2 id="H-叁佰爱抠的序列"><a href="#H-叁佰爱抠的序列" class="headerlink" title="H. 叁佰爱抠的序列"></a>H. 叁佰爱抠的序列</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>叁佰爱抠的智商有三百，他特别喜欢构造各种各样的序列。<br>这天他突然想出了这样一个序列：<br>一个长度为n的序列A，元素的值域是$[1,m]$。<br>对于任意$x,y\in[1,m],x\neq y$，序列中存在一个位置$p(1\le p\lt n)$，满足$A[p]=x,A[p+1]=y$或者$A[p+1]=x,A[p]=y$。<br>叁佰爱抠很开心地走了。作为他忠实粉丝的你只听清楚了$n$的大小，那么你好奇了起来，$m$最大值可以取到多少，并且打算自己动手构造一个这样的序列。</p></blockquote><h3 id="题目分析-7"><a href="#题目分析-7" class="headerlink" title="题目分析"></a>题目分析</h3><p>考试时试了一波OEIS，然而并没有什么卵用。  </p><p>本题近似等价于求$n$个点完全图的欧拉回路。<br>通过二分求出$n$的值，需要注意的是，因为要保证有欧拉回路，所以如果二分出来的$n$是偶数，那么应该增加$\frac n2-1$条重边才能保证奇点只有$2$个以保证欧拉回路。  </p><p>题目给出的边数减去二分出来的边数可以直接用来构造重边。<br>剩下的跑欧拉回路即可。  </p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><p>yk的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=(<span class="number">1L</span>L&lt;&lt;<span class="number">29</span>);</span><br><span class="line"><span class="keyword">int</span> head[maxn],to[maxn&lt;&lt;<span class="number">1</span>],next1[maxn&lt;&lt;<span class="number">1</span>],vis[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> aa[maxn],e1,ee;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ++e1;next1[e1]=head[u];head[u]=e1;to[e1]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler_path</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=head[u];i;i=next1[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[i]=vis[((i<span class="number">-1</span>)^<span class="number">1</span>)+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        euler_path(to[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    aa[++ee]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ans=<span class="number">1L</span>L*x*(x<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>) ans+=x/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    ll n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    ll l=<span class="number">1</span>,r=<span class="number">2e9</span>,ans;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(solve(mid)&lt;=n<span class="number">-1</span>)&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll a=n<span class="number">-1</span>-solve(ans);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">2000000</span>) <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=ans;k++)&#123;</span><br><span class="line">            addedge(i,k);</span><br><span class="line">            addedge(k,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans/<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">                addedge(i*<span class="number">2</span><span class="number">-1</span>,i*<span class="number">2</span>);</span><br><span class="line">                addedge(i*<span class="number">2</span>,i*<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            euler_path(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> euler_path(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> first=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ee;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first) first=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,aa[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++) <span class="built_in">printf</span>(<span class="string">" %d"</span>,aa[ee]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="I-堡堡的宝藏"><a href="#I-堡堡的宝藏" class="headerlink" title="I. 堡堡的宝藏"></a>I. 堡堡的宝藏</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>堡堡有一张大小为$n\times m$的地图，每个位置都有一个宝箱，宝箱要通过一定数量的投币才能打开。<br>堡堡想要打开所有的宝箱，但是他不想浪费太多钱。幸运的是，位置相邻的宝箱内部是相连的。<br>具体地说，存在$k$个约束条件，每个约束条件为：(保证$(x_1,y_1)$与$(x_2,y_2)$相邻，$coin[x][y]$代表对宝箱$(x,y)$投币数量)  </p><script type="math/tex; mode=display">coin[x_1][y_1]+coin[x_2][y_2]\ge w</script><p>请你求出堡堡最少需要投多少个币才能打开所有的宝箱。</p></blockquote><h3 id="题目分析-8"><a href="#题目分析-8" class="headerlink" title="题目分析"></a>题目分析</h3><p>标解的算法是KM算法，因为KM算法可以用来解决一类不等式问题。<br>然而考场上用<a href="/simplex-algorithm-notes/">单纯形算法</a>水过去了。<br>和<a href="/ZJOI2013-defend/">这道题</a>基本上一样，时间复杂度$O(\text{不清楚})$。  </p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(x&lt;<span class="string">'0'</span>||x&gt;<span class="string">'9'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;</span><br><span class="line">x=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(x&gt;=<span class="string">'0'</span>&amp;&amp;x&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;</span><br><span class="line">x=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1505</span>,maxm=<span class="number">1505</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;=eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> x&gt;eps?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Simplex</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">double</span> a[maxn][maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//Matrix a : m rows,n lines</span></span><br><span class="line"><span class="keyword">this</span>-&gt;n=m;</span><br><span class="line"><span class="keyword">this</span>-&gt;m=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> in,<span class="keyword">int</span> out)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=m; i++) <span class="comment">//reset constraint "out"</span></span><br><span class="line"><span class="keyword">if</span>(i!=in)a[out][i]/=-a[out][in];</span><br><span class="line">a[out][in]=<span class="number">1</span>/a[out][in];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123; <span class="comment">//recalculate other constraints </span></span><br><span class="line"><span class="keyword">if</span>(i==out||dcmp(a[i][in])==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">double</span> t=a[i][in];</span><br><span class="line">a[i][in]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=m; j++)a[i][j]+=t*a[out][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> in=<span class="number">0</span>,out=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> Min=<span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line"><span class="keyword">if</span>(dcmp(a[<span class="number">0</span>][i])&gt;<span class="number">0</span>) &#123;</span><br><span class="line">in=i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!in)<span class="keyword">return</span> a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">if</span>(dcmp(a[i][in])&lt;<span class="number">0</span>&amp;&amp;a[i][<span class="number">0</span>]/-a[i][in]&lt;Min) &#123;</span><br><span class="line">Min=a[i][<span class="number">0</span>]/-a[i][in];</span><br><span class="line">out=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!out)<span class="keyword">throw</span> ; <span class="comment">//unbounded</span></span><br><span class="line">pivot(in,out);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; fst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M,k;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (x<span class="number">-1</span>)*M+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N=Get_Int();</span><br><span class="line">M=Get_Int();</span><br><span class="line">k=Get_Int();</span><br><span class="line">n=N*M;</span><br><span class="line">fst.init(n,k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)fst.a[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),y=Get_Int(),xx=Get_Int(),yy=Get_Int(),w=Get_Int();</span><br><span class="line">fst.a[id(x,y)][i]=fst.a[id(xx,yy)][i]=<span class="number">-1</span>;</span><br><span class="line">fst.a[<span class="number">0</span>][i]=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)(fst.Solve()));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-邦邦的2-SAT模板"><a href="#J-邦邦的2-SAT模板" class="headerlink" title="J. 邦邦的2-SAT模板"></a>J. 邦邦的2-SAT模板</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>邦邦是图论白痴，他有一天捡到了一份模板，可以解决2-SAT问题并输出方案。<br>所谓2-SAT问题，指：有$n$个布尔变量$a_i$，有$m$个形如$x\ or\ y=true$的方程，$x$和$y$为$a_i$或者$!a_i$，求是否存在一组$a_i$的取值满足所有方程。<br>戳戳是真正的图论大师，他看了看邦邦的板子，发现这段代码会超时。邦邦不相信，戳戳要赶去约会了，于是希望你构造一个数据让邦邦这段代码超时。<br>具体地，你需要根据给定的n按如下格式构造：<br>第一行输出一个整数$m(0\le m\le n)$，代表有$m$个方程。<br>接下来$m$行，给出两个数$x$和$y(−n\le x,y\le n,x,y\neq0)$，若数字为负数，代表$!a_i$，否则代表$a_i$。<br>要求保证代码中solve的返回值是true(存在至少一组解)，且$CNT$的值满足</p><script type="math/tex; mode=display">n^2\le2\times cnt</script><p>邦邦的2-SAT模板见附录。</p></blockquote><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> g[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>],v[N&lt;&lt;<span class="number">1</span>],num;</span><br><span class="line"><span class="keyword">int</span> q[N&lt;&lt;<span class="number">1</span>],t;</span><br><span class="line"><span class="keyword">bool</span> vis[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> CNT;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">nxt[++num]=g[x];</span><br><span class="line">v[num]=y;</span><br><span class="line">g[x]=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">CNT++;</span><br><span class="line"><span class="keyword">if</span>(vis[x&gt;n?x-n:x+n])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(vis[x])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">vis[q[++t]=x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=g[x];i;i=nxt[i])<span class="keyword">if</span>(!dfs(v[i]))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!vis[i]&amp;&amp;!vis[i+n])&#123;</span><br><span class="line">t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!dfs(i))&#123;</span><br><span class="line"><span class="keyword">while</span>(t)vis[q[t--]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!dfs(i+n))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)x=n-x;<span class="keyword">if</span>(y&lt;<span class="number">0</span>)y=n-y;</span><br><span class="line">add(x&gt;n?x-n:x+n,y);add(y&gt;n?y-n:y+n,x);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目分析-9"><a href="#题目分析-9" class="headerlink" title="题目分析"></a>题目分析</h3><p>考场上没想出来，其实构造方法不是很难。<br>如图所示：<br><img src="/wannafly-camp-day2/J.svg"><br>于是输出$-i$和$i+1$，最后输出$-n$和$-n$即可。  </p><p>来自出题人：</p><blockquote><p>没错，本题就是为了告诉在座各位你们的板子可能是个暴力…..</p></blockquote><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=Get_Int(),m=n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,-i,i+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,-n,-n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-破忒头的匿名信"><a href="#K-破忒头的匿名信" class="headerlink" title="K. 破忒头的匿名信"></a>K. 破忒头的匿名信</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>破忒头想要写一封匿名信来做坏事，由于他不想被认出自己的笔迹，因此他想要雇佣萨博来帮他写这封信。萨博按照这样的标准来收费：他的词典里有$N$个单词，第$i$个单词的单价是$p_i$。如果你提供一个长度为$M$的序列$a_1,a_2,\ldots,a_M(1\le a_i\le N)$，那么你需要支付$\sum_{i=1}^Mp_{a_i}$的金钱，而萨博会依次往信里写上。破忒头希望支付最少的金钱，让萨博写的内容恰好为他想要的信件内容$T$。请你告诉破忒头，最少需要付多少钱，能让萨博写出他想要的匿名信，或者告诉他这是不可能做到的。</p></blockquote><h3 id="题目分析-10"><a href="#题目分析-10" class="headerlink" title="题目分析"></a>题目分析</h3><p>考场上sb了，以为AC自动机来做是$n^2$的，但其实AC自动机上不同长度的单词至多有$\sqrt n$种，同时trie树与后缀树的树高都不会超过$\sqrt n$，这两种描述是等价的，下面进行证明。<br>限定串的总长度为$n$，定义trie树上一个结点的有效高度为从根到这个结点时经过的单词结尾结点的个数，定义trie树的有效高度为所有结点有效高度的最大值。<br>假设加入串长度递增，若想使得trie树的有效高度变高，那么我只能从上一次插入的串的结束结点处继续增加结点，也就是说上一个串是当前串的前缀，故增加的结点数$f(i)=f(i-1)+x$，$x$是大于等于$1$的自然数，显然其他情况下的串都不会使得trie树的有效高度变高。<br>那么$1+2+3+\cdots+\sqrt n=O(n)$，也就是说trie树的有效高度至多为$\sqrt n$。  </p><p>如果我们在用AC自动机DP的时候暴力跳$fail$指针，由于后缀树的树高是没有保证的，所以复杂度最坏$O(n^2)$，但利用到上面证明的性质，如果我们能够快速定位这些有效结点（是单词结尾的结点），我们便可以$O(\sqrt n)$跳完后缀树。<br>这就是AC自动机上的$next$指针，在menci的学习笔记里也有介绍，一个结点的$next$指针指向它的$fail$链上距离它最近的一个单词结尾结点。<br>有了$next$指针，每次跳跃都可以进行一次有效的DP转移，故时间复杂度为$O(n\sqrt n)$。$next$指针的求法也很简单，详见代码。  </p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Aho_Corasick_Automaton</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> child[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> fail,next;</span><br><span class="line"><span class="keyword">int</span> value,length;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;fill(child,child+<span class="number">26</span>,<span class="number">0</span>);fail=flag=next=length=<span class="number">0</span>;value=INT_MAX;&#125;</span><br><span class="line">&#125; tree[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ch(x,i) tree[x].child[i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fail(x) tree[x].fail</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(x) tree[x].next</span></span><br><span class="line">Aho_Corasick_Automaton() &#123;init();&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;tree[cnt=<span class="number">0</span>].clear();&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123;tree[++cnt].clear();<span class="keyword">return</span> cnt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">0</span>,len=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j=s[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!ch(now,j))ch(now,j)=newnode();</span><br><span class="line">now=ch(now,j);</span><br><span class="line">&#125;</span><br><span class="line">tree[now].flag=<span class="number">1</span>;</span><br><span class="line">tree[now].value=min(tree[now].value,v);</span><br><span class="line">tree[now].length=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">Q.push(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> now=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> &amp;son=ch(now,i);</span><br><span class="line"><span class="keyword">if</span>(!son) &#123;</span><br><span class="line">son=now?ch(fail(now),i):<span class="number">0</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">fail(son)=now?ch(fail(now),i):<span class="number">0</span>;</span><br><span class="line">next(son)=tree[fail(son)].flag?fail(son):next(fail(son));</span><br><span class="line">Q.push(son);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; acam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">acam.insert(s,Get_Int());</span><br><span class="line">&#125;</span><br><span class="line">acam.buildfail();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> Now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">f[i]=LLONG_MAX/<span class="number">2</span>;</span><br><span class="line">Now=acam.tree[Now].child[s[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=Now; j; j=acam.tree[j].next)f[i]=min(f[i],f[i-acam.tree[j].length]+acam.tree[j].value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]==LLONG_MAX/<span class="number">2</span>?<span class="number">-1</span>:f[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;游记及总结在&lt;a href=&quot;https://www.zhihu.com/answer/973191974&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;逼乎&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;全部补完~！&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://blog.bill.moe/categories/ACM/"/>
    
    
      <category term="数位动规" scheme="https://blog.bill.moe/tags/%E6%95%B0%E4%BD%8D%E5%8A%A8%E8%A7%84/"/>
    
      <category term="AC自动机" scheme="https://blog.bill.moe/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="后缀自动机" scheme="https://blog.bill.moe/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="单纯形" scheme="https://blog.bill.moe/tags/%E5%8D%95%E7%BA%AF%E5%BD%A2/"/>
    
      <category term="比赛酱油记" scheme="https://blog.bill.moe/tags/%E6%AF%94%E8%B5%9B%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
      <category term="博弈论" scheme="https://blog.bill.moe/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="SG函数" scheme="https://blog.bill.moe/tags/SG%E5%87%BD%E6%95%B0/"/>
    
      <category term="前缀和" scheme="https://blog.bill.moe/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="启发式合并" scheme="https://blog.bill.moe/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
      <category term="欧拉图" scheme="https://blog.bill.moe/tags/%E6%AC%A7%E6%8B%89%E5%9B%BE/"/>
    
      <category term="2-sat" scheme="https://blog.bill.moe/tags/2-sat/"/>
    
      <category term="树链剖分维护树形动规" scheme="https://blog.bill.moe/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E7%BB%B4%E6%8A%A4%E6%A0%91%E5%BD%A2%E5%8A%A8%E8%A7%84/"/>
    
      <category term="dsu on tree" scheme="https://blog.bill.moe/tags/dsu-on-tree/"/>
    
  </entry>
  
  <entry>
    <title>2020 CCPC wannafly 冬令营 Day1 游记+解题报告</title>
    <link href="https://blog.bill.moe/wannafly-camp-day1/"/>
    <id>https://blog.bill.moe/wannafly-camp-day1/</id>
    <published>2020-01-13T01:40:16.000Z</published>
    <updated>2020-07-12T13:40:37.782Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>游记及总结在<a href="https://www.zhihu.com/answer/972183481" target="_blank" rel="noopener">逼乎</a>。</p><p>所有题目已更新。</p><a id="more"></a><h2 id="A-期望逆序对"><a href="#A-期望逆序对" class="headerlink" title="A. 期望逆序对"></a>A. 期望逆序对</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>有$n$个独立的随机变量，其中$x_i$的值是一个从$[l_i,r_i]$中随机选取的整数，即对于$[l_i,r_i]$中的任何一个整数$j$，$x_i=j$的概率都是$(r_i−l_i+1)​^{−1}$。<br>现在你需要给出一个长度为$n$的排列$p$，那么可以得到一个长度为$n$的随机变量序列。你的目标是让结果序列的逆序对个数的期望尽可能少。<br>求逆序对个数的期望的最小值。</p></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>贪心，按照中点从小到大排序，然后枚举两两区间计算形成逆序对的概率即可。<br>计算逆序对概率的时候要分三种情况讨论，推推公式就可以了。<br>这么简单居然考试没做。（恼）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5005</span>;</span><br><span class="line"><span class="keyword">const</span> LL p=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">LL l,r,inv;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;b) &#123;<span class="keyword">return</span> l+r&lt;b.l+b.r;&#125;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL ans,inv2=(p+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Quick_Pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">LL sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>,a=a*a%p)<span class="keyword">if</span>(b&amp;<span class="number">1</span>)sum=sum*a%p;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span> </span>&#123;<span class="keyword">return</span> Quick_Pow(a,p<span class="number">-2</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(LL &amp;x,LL v)</span> </span>&#123;x=(x+v)%p;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">a[i].l=Get_Int();</span><br><span class="line">a[i].r=Get_Int();</span><br><span class="line">a[i].inv=inv(a[i].r-a[i].l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].r&lt;=a[j].l)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i].l&lt;=a[j].l&amp;&amp;a[j].r&gt;a[i].r)add(ans,a[i].inv*a[j].inv%p*(a[i].r-a[j].l)%p*(a[i].r-a[j].l+<span class="number">1</span>)%p*inv2%p);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i].l&gt;a[j].l&amp;&amp;a[j].r&gt;a[i].r)add(ans,a[i].inv*a[j].inv%p*((a[i].r-a[i].l+<span class="number">1</span>)*(a[i].l-a[j].l)%p+(a[i].r-a[i].l+<span class="number">1</span>)*(a[i].r-a[i].l)%p*inv2%p)%p);</span><br><span class="line"><span class="keyword">else</span> add(ans,a[i].inv*a[j].inv%p*(<span class="number">2</span>*a[i].r-a[j].l-a[j].r)%p*(a[j].r-a[j].l+<span class="number">1</span>)%p*inv2%p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-密码学"><a href="#B-密码学" class="headerlink" title="B. 密码学"></a>B. 密码学</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>考虑一种加密方式，它需要一个任意长度的原文$m$和秘钥$key$，其中要求原文和秘钥只包含大写和小写的英文字符。<br>首先定义字符之间的加密，用字符$a$去加密字符$b$的结果是：  </p><ol><li>首先把$a$和$b$转成数字$x$和$y$。转换的规则是，小写字母$a$到$z$依次对应$0$到$25$，大写字母依次对应$26$到$51$。  </li><li>计算$x$和$y$的和$z$，对$52$取模，即计算$(x+y)\mod52$。  </li><li>返回数字$z$对应的字符。  </li></ol><p>现在来讲如何用秘钥 key 来加密原文$m$：  </p><ol><li>如果秘钥的 key 的长度小于$m$，那么不停重复 key 直到长度不小于$m$为止。举例来说，如果原文是 beijing，秘钥是 PKUSAA，那么秘钥需要被重复称 PKUSAAPKUSAA。  </li><li>假设原文的长度是$n$，那么对于每一个$[1,n]$的数字$i$，都用 key 的第$i$个字符去加密$m$的第$i$个字符。  </li><li>返回结果。</li></ol><p>那么用 PKUSAA 去加密 beijing 的结果就是：QOcbINV。<br>现在火山哥有$n$个字符串，$s_1$到$s_n$，他对这些字符串做了$m$次加密操作：第$i$次加密操作用第$s_{x_i}$去加密$s_{y_i}$，并把$s_{y_i}$替换成加密结果。<br>现在依次给出$m$次加密操作，以及加密操作结束后每一个字符串的模样，你可以还原出这$n$个字符串原来的模样吗？</p></blockquote><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>倒序模拟即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],b[maxn];</span><br><span class="line"><span class="built_in">string</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tonum</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">isupper</span>(x)?x-<span class="string">'A'</span>+<span class="number">26</span>:x-<span class="string">'a'</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Tochar</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&lt;<span class="number">26</span>?x+<span class="string">'a'</span>:x<span class="number">-26</span>+<span class="string">'A'</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Decode</span><span class="params">(<span class="built_in">string</span> x,<span class="built_in">string</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lenx=x.length(),leny=y.length();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; i&lt;leny; i++,j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=lenx)j=<span class="number">0</span>;</span><br><span class="line">y[i]=Tochar((Tonum(y[i])-Tonum(x[j])+<span class="number">52</span>)%<span class="number">52</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)<span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m; i&gt;=<span class="number">1</span>; i--)s[b[i]]=Decode(s[a[i]],s[b[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">cout</span>&lt;&lt;s[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-染色图"><a href="#C-染色图" class="headerlink" title="C. 染色图"></a>C. 染色图</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>定义一张无向图$G=⟨V,E⟩$是$k$可染色的当且仅当存在函数$f:V↦\{1,2,⋯,k\}$满足对于$G$中的任何一条边$(u,v)$，都有$f(u)\neq f(v)$。<br>定义函数$g(n,k)$的值为所有包含$n$个点的无自环、无重边的$k$可染色无向图中的边数最大值。举例来说，$g(3,1)=0,g(3,2)=2,g(3,3)=3$。<br>现在给出三个整数$n,l,r$，你需要求解：$(\sum_{i=l}^rg(n,i))\mod 998244353$</p></blockquote><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>设第$i$种颜色的点有$x_i$个，那么为了获得最大的边数，我们应在不同颜色点间都连边，最大边数即为：</p><script type="math/tex; mode=display">g(n,m)=\begin{pmatrix}n\\2\end{pmatrix}-\sum_{i=1}^m\begin{pmatrix}x_i\\2\end{pmatrix}</script><p>由于$f(x)=g(n,m)$的对称性，将$n$尽量平均地分给所有$x_i$，可以让$g(n,m)$最大。此时有$n\bmod m$种颜色有$\lceil\frac nm\rceil$个点，剩下的$m-n\bmod m$个颜色只有$\lfloor\frac nm\rfloor$个点。</p><script type="math/tex; mode=display">g(n,m)=\begin{pmatrix}n\\2\end{pmatrix}-(n\bmod m)\begin{pmatrix}\lceil\frac nm\rceil\\2\end{pmatrix}-(m-n\bmod m)\begin{pmatrix}\lfloor\frac nm\rfloor\\2\end{pmatrix}</script><p>根据恒等式$\lceil\frac nm\rceil=\lfloor\frac {n-1}m\rfloor+1,n\bmod m=n-m\lfloor\frac nm\rfloor$化简得到：</p><script type="math/tex; mode=display">g(n,m)=\begin{pmatrix}n\\2\end{pmatrix}-(n-m\lfloor\frac nm\rfloor)\begin{pmatrix}\lfloor\frac {n-1}m\rfloor+1\\2\end{pmatrix}-(m-n+m\lfloor\frac nm\rfloor)\begin{pmatrix}\lfloor\frac nm\rfloor\\2\end{pmatrix}</script><p>于是使用数论分块就可以在$\sqrt n$的时间内得出每组数据的解了。<br>这种解法有一个$2$的常数，本题还可以考虑使用$n$个数的平方和公式求解，就可以省去这个常数，下方附上队友yk的代码。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>常数$2$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">LL n,L,R;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get</span><span class="params">(LL L,LL R)</span> </span>&#123;<span class="keyword">return</span> (L+R)*(R-L+<span class="number">1</span>)/<span class="number">2</span>%p;&#125; <span class="comment">//等差数列求和</span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">C2</span><span class="params">(LL x)</span> </span>&#123;<span class="keyword">return</span> x*(x<span class="number">-1</span>)/<span class="number">2</span>%p;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">g</span><span class="params">(LL n,LL l,LL r)</span> </span>&#123;</span><br><span class="line">LL Down=n/l,Up=(n<span class="number">-1</span>)/l+<span class="number">1</span>,len=r-l+<span class="number">1</span>;</span><br><span class="line">LL tmp=Down*get(l,r)%p;</span><br><span class="line">LL val1=(len*n%p-tmp+p)%p*C2(Up)%p,val2=(get(l,r)-n*len%p+tmp+p)%p*C2(Down)%p;</span><br><span class="line"><span class="keyword">return</span> (val1+val2)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=Get_Int();</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">L=Get_Int();</span><br><span class="line">R=Get_Int();</span><br><span class="line"><span class="keyword">int</span> Next=<span class="number">1</span>;</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L; i&lt;=min(R,n<span class="number">-1</span>); i=Next+<span class="number">1</span>) &#123;</span><br><span class="line">Next=min(R,min(n/(n/i),(n<span class="number">-1</span>)/((n<span class="number">-1</span>)/i)));</span><br><span class="line">ans=(ans+g(n,i,Next))%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(C2(n)*(R-L+<span class="number">1</span>)%p-ans+p)%p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>yk的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) (x)*(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100007</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1</span>&lt;&lt;<span class="number">29</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r-l+<span class="number">1</span>)*(l+r)/<span class="number">2</span>%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll N,ll L,ll R)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll l=L,r;l&lt;=R;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(R,N/(N/l));ll y=N/l;</span><br><span class="line">     <span class="comment">//   cout&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">        ans+=(mod-sum(l,r)*(((y*y)%mod+y)%mod))%mod+(<span class="number">2</span>*y+<span class="number">1</span>)%mod*N%mod*(r-l+<span class="number">1</span>)%mod;</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> (N*N%mod*(R-L+<span class="number">1</span>)%mod+mod-ans)%mod*(mod+<span class="number">1</span>)/<span class="number">2</span>%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=read();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n=read(),L=read(),R=read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve(n,L,R)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="D-生成树"><a href="#D-生成树" class="headerlink" title="D. 生成树"></a>D. 生成树</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>首先给出一些简单的概念：</p><ul><li>对于一张 无向图$G=⟨V,E⟩$，树$T=⟨V,E′⟩$是$G$的生成树当且仅当$E′$是$E$的子集。  </li><li>两棵$G$的生成树$T_1=⟨V,E_1⟩,T_2=⟨V,E_2⟩$是不同的当且仅当它们使用的边集不同。</li><li>集合$\mathcal{T}(G)$表示图$G$所有不同的生成树形成的集合。</li><li>函数$s(G,T)$来衡量树$T$和图$G$的相似度，它的值等于同时出现在$T$和$G$中的边的数量。<br>现在给出两张$n$个点的无向图$G_1,G_2$，你需要求：$\sum_{T\in \mathcal{T}(G_1)}s(G_2,T)$</li></ul></blockquote><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题需要用到矩阵树定理与基尔霍夫矩阵。<br>矩阵树定理告诉我们可以使用基尔霍夫矩阵求生成树的个数。<br>然而这有扩展版，带权的基尔霍夫矩阵可以求一些奇奇怪怪的东西。<br>如果定义一棵生成树的权值是其所有边权相乘，那么构造带权的基尔霍夫矩阵：</p><ol><li>$\forall1\le i\le n,A_{i,i}$为与$i$相连的所有边的权值和。  </li><li>$\forall1\le i\neq j\le n,A_{i,j}$为$(i,j)$边权的相反数。  </li></ol><p>删去矩阵第$n$行第$n$列，得到的矩阵行列式即为所有生成树权值的和。<br>那么对于这道题来说，我们需要构建一个更奇怪的图来将原来的两个图的边合并起来。<br>我们定义只在$G_1$中的边在新图$G_3$中边权为$1$，而在$G_1,G_2$中都存在的边边权为$x$，那么$G_3$生成的基尔霍夫矩阵$A$中每一个元素都是一个关于$x$的多项式，其行列式是一个$n-1$阶的多项式：$\left|A\right|=f(x)=\sum_{i=0}^{n-1}a_ix^i$，考虑$a_i$的意义，即为有$a_i$个生成树有$i$条公共边，因此答案就是$\sum i\times a_i=f’(1)$。  </p><p>行列式$\left|A(x)\right|$求导可以用公式：<br><img src="/wannafly-camp-day1/D.png" alt></p><p>如果继续用行列式的展开化简我们可以得到：</p><script type="math/tex; mode=display">f'(x)=\left|A(x)\right|\sum_{i=1}^n\sum_{j=1}^n(A(x)^{-1})_{i,j}\times A'(x)_{i,j}</script><p>取$x=1$，用高斯消元算逆矩阵和行列式就可以了。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">405</span>,p=<span class="number">998244353</span>,x=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Quick_Pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">LL sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>,a=a*a%p)<span class="keyword">if</span>(b&amp;<span class="number">1</span>)sum=sum*a%p;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL x)</span> </span>&#123;<span class="keyword">return</span> Quick_Pow(x,p<span class="number">-2</span>);&#125;</span><br><span class="line"></span><br><span class="line">LL A[maxn][maxn&lt;&lt;<span class="number">1</span>],B[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> a[maxn][maxn],b[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Gauss_Jordan</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">LL r=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> row=i;</span><br><span class="line"><span class="keyword">for</span>(; row&lt;=n; row++)<span class="keyword">if</span>(A[row][i])<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(row&gt;n)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(row!=i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)swap(A[i][j],A[row][j]);</span><br><span class="line">r=(p-r)%p;</span><br><span class="line">&#125;</span><br><span class="line">r=r*A[i][i]%p;</span><br><span class="line">LL t=inv(A[i][i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)A[i][j]=A[i][j]*t%p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line"><span class="keyword">if</span>(j!=i) &#123;</span><br><span class="line">t=A[j][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=m; k++)A[j][k]=(A[j][k]-t*A[i][k]%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">"%s"</span>,b[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">'1'</span>&amp;&amp;b[i][j]==<span class="string">'1'</span>) &#123;</span><br><span class="line">A[i][j]=-x;</span><br><span class="line">A[i][i]+=x;</span><br><span class="line">B[i][j]=p<span class="number">-1</span>; <span class="comment">//导数</span></span><br><span class="line">B[i][i]+=<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]==<span class="string">'1'</span>) &#123;</span><br><span class="line">A[i][j]=<span class="number">-1</span>;</span><br><span class="line">A[i][i]+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n--;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)A[i][n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)A[i][i+n]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=(n&lt;&lt;<span class="number">1</span>); j++)A[i][j]=(A[i][j]+p)%p;</span><br><span class="line">LL r=Gauss_Jordan(n,n&lt;&lt;<span class="number">1</span>),ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)ans=(ans+A[i][j+n]*B[i][j]%p)%p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans*r%p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-树与路径"><a href="#E-树与路径" class="headerlink" title="E. 树与路径"></a>E. 树与路径</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>在一棵有根树$T$上，任何两点间的最短路径都能够分为两个阶段：</p><ol><li>从起点出发，沿着向根的方向走若干条边。</li><li>向着终点，沿着离开根的方向走若干条边。  </li></ol><p>定义一条路径的权值为向上走的边数乘上向下走的边数。特殊地，当起点等于终点的时候，两阶段的边数都是$0$；当起点是终点的祖先的时候，第一阶段的边数是$0$；当终点是起点的祖先的时候，第二阶段的边数是 0———这三种情况下，路径的权值都是$0$。<br>现在给出一棵$n$个节点的无根树$T$和$m$条路径$(a_i,b_​i)$。对于每一个$r\in[1,n]$，你需要计算当$r$是根节点的时候，所有路径的权值和是多少。  </p></blockquote><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>考试的时候傻了，觉得这个转移必定不可维护，理由是中间点没法考虑，但是如果考虑贡献作差的话就可以维护了。<br>假设$A_x$是以$x$为根的答案（假设当$1$为根时，$x$的父亲是$f_x$），那么$A_1$很容易求出来，现在我们考虑换根求$A_x$，那么只需要考虑$A_x-A_{f_x}$：</p><ol><li>如果一条路径不同时经过$x$与$f_x$，则他们对$A_x,A_{f_x}$的贡献相同。  </li><li>如果路径同时经过$x,f_x$，设路径长度为$len$，向上段路径长度是$l$，那么路径对$A_x$的贡献是$l(len-l)$，而它对$A_{f_x}$的贡献是$(l+1)(len-l-1)$，贡献差为$2l+1-len$。  </li></ol><p>因此我们需要对树上所有的结点$i$，统计同时经过$i,f_i$的路径的$2l+1-len$的和，这样我们就可以通过换根求出$A_i$，问题转化为如何对于每一个$i$求出$2l+1-len$的和。<br>考虑对于一条路径$[u,v]$，它对$u$产生了$1-len$的贡献，它对$f_u$产生了$3-len$的贡献，依次类推，它对每一个路径$[u,lca)$上的点$i$产生了$1-len+2dep_u-2dep_i$的贡献。这是一个等差数列，第$i$个点获得的贡献可以转化为一个关于$dep_i$的一次函数：$a_idep_i+b_i$。<br>每一条路径的贡献可以通过树上差分处理，然后从下往上统计所有的$a_i,b_i$，就可以求出贡献差$A_x-A_{f_x}$了，然后换根即可。  </p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">300005</span>,K=<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,Depth[maxn],p[maxn][K];</span><br><span class="line">LL f[maxn],a[maxn],b[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> fa,<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">Depth[Now]=depth;</span><br><span class="line">p[Now][<span class="number">0</span>]=fa;</span><br><span class="line"><span class="keyword">int</span> K=log2(Depth[Now]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=K; i++)p[Now][i]=p[p[Now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">if</span>(Next==fa)<span class="keyword">continue</span>;</span><br><span class="line">Dfs(Next,Now,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Depth[x]&lt;Depth[y])swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=K<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line"><span class="keyword">if</span>(Depth[x]==Depth[y])<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Depth[x]-(<span class="number">1</span>&lt;&lt;i)&gt;=Depth[y])x=p[x][i];</span><br><span class="line"><span class="keyword">if</span>(x==y)<span class="keyword">return</span> y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=K<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line"><span class="keyword">if</span>(p[x][i]&amp;&amp;p[x][i]!=p[y][i]) &#123;</span><br><span class="line">x=p[x][i];</span><br><span class="line">y=p[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">if</span>(Next==p[Now][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">Dfs1(Next);</span><br><span class="line">a[Now]+=a[Next];</span><br><span class="line">b[Now]+=b[Next];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">f[Now]+=a[Now]*Depth[Now]+b[Now];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">if</span>(Next==p[Now][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">f[Next]+=f[Now];</span><br><span class="line">Dfs2(Next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;edges[x].push_back(y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),y=Get_Int();</span><br><span class="line">AddEdge(x,y);</span><br><span class="line">AddEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">Dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),y=Get_Int(),lca=LCA(x,y),len=Depth[x]+Depth[y]<span class="number">-2</span>*Depth[lca],lenl=Depth[x]-Depth[lca];</span><br><span class="line">a[x]-=<span class="number">2</span>;</span><br><span class="line">a[y]-=<span class="number">2</span>;</span><br><span class="line">a[lca]+=<span class="number">4</span>;</span><br><span class="line">b[x]+=<span class="number">1</span>-len+<span class="number">2</span>*Depth[x];</span><br><span class="line">b[y]+=<span class="number">1</span>-len+<span class="number">2</span>*Depth[y];</span><br><span class="line">b[lca]-=<span class="number">1</span>-len+<span class="number">2</span>*Depth[x]+<span class="number">1</span>-len+<span class="number">2</span>*Depth[y];</span><br><span class="line">f[<span class="number">1</span>]+=<span class="number">1l</span>l*lenl*(len-lenl);</span><br><span class="line">&#125;</span><br><span class="line">Dfs1(<span class="number">1</span>);</span><br><span class="line">Dfs2(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-乘法"><a href="#F-乘法" class="headerlink" title="F. 乘法"></a>F. 乘法</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给出一个长度为$n$的数列和一个长度为$m$的数列 ，可以构造得到一个$n\times m$的矩阵$C$，其中$C_{i,j}=A_i\times B_j$。<br>给出整数$K$，你需要求出$C$中第$K$大的数的值。</p></blockquote><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>这道题的难点在于有负数和$0$，可以分成六个表用二分+双指针（难调），也可以二分+lowerbound（但也要特殊处理$0$）。  </p><p>这道题我们调了3个小时，可以说是day1演了的罪魁祸首，主要问题出在配合上，一开始写的是lowerbound，因为$0$的问题出锅，讨论后发现双指针不需要特殊处理，于是重新写双指针，结果更难调，3个小时后又换回lowerbound处理0才过。  </p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>队友的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> a[maxn],b[maxn],rb[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cnt += b + m - upper_bound(b,b+m,(<span class="keyword">long</span> <span class="keyword">double</span>)mid / a[i] + eps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[i]&lt; <span class="number">0</span>) &#123;</span><br><span class="line">cnt += rb + m - upper_bound(rb,rb+m,-((<span class="keyword">long</span> <span class="keyword">double</span>)mid/a[i]) + eps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> zero=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="keyword">if</span>(a[i]==<span class="number">0</span>)zero++;</span><br><span class="line"><span class="keyword">if</span>(mid&lt;<span class="number">0</span>) cnt+=zero*m;</span><br><span class="line"><span class="comment">//printf("mid=%lld cnt=%lld\n",mid,cnt);</span></span><br><span class="line"><span class="keyword">return</span> cnt &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">work</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> _k)</span> </span>&#123;</span><br><span class="line">k = _k - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">-1e13</span>, r = <span class="number">1e13</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0x8000000000000000</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">ans = mid;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) res.push_back(a[i] * b[j]);</span><br><span class="line">sort(res.begin(),res.end());</span><br><span class="line">reverse(res.begin(),res.end());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----DEBUG BEGIN-----\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x:res) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----DEBUG  END -----\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> _k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;m,&amp;_k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%Lf"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">"%Lf"</span>,&amp;b[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) rb[i] = -b[i];</span><br><span class="line"><span class="comment">//debug();</span></span><br><span class="line">sort(a,a+n);</span><br><span class="line">sort(b,b+m);</span><br><span class="line">sort(rb,rb+m);</span><br><span class="line"><span class="comment">//k = _k - 1;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,work(_k));</span><br><span class="line"><span class="comment">//for (int mid=-10;mid&lt;=10;mid++) printf("debug mid=%d %lld\n",mid,check(mid));</span></span><br><span class="line"><span class="comment">//for (long long _k=1;_k&lt;=n*m;_k++) printf("debug k=%lld %lld\n",_k,work(_k));</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="G-圆凸包"><a href="#G-圆凸包" class="headerlink" title="G. 圆凸包"></a>G. 圆凸包</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给出$n$个点求他们的凸包是一个经典问题，所以出了一道稍微难一点的题。<br>给出平面上$n$个圆，第$i$个圆的圆心是$(x_i,y_i)$，半径是$r_i$。定义这$n$个点的凸包为所有满足以下条件的点$P$形成的区域：存在点$A,B$和常数$\alpha\in[0,1]$满足$A,B$都在某个圆的内部（所在的圆可以不同）且$P=\alpha A+(1−\alpha)B$。换句话说，这$n$个点的凸包等于这$n$个圆内部的所有点形成的凸包。<br>现在给出这$n$个圆，试求这$n$个圆形成的凸包的周长。<br>给出整数$K$，你需要求出$C$中第$K$大的数的值。</p></blockquote><h3 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h3><p>很容易想到凸包上存在的只可能是圆弧或者公切线。<br>而一个点要成为凸包上的点也必须满足条件：  </p><ol><li>它是两个圆的外切点</li><li>它不被任何圆覆盖<br>处理公切线部分的凸包很容易想，主要问题在于如何判断凸包点集中的相邻两点连接它们的是线段还是圆弧。<br>这里吉老师给出了一个性质：如果这两个点在一个圆上，连接它们的是圆弧，否则是线段。<br>接下来就贴板子就可以了。  </li></ol><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><p>没有，不想写了。（有一定概率会回来补）  </p><h2 id="H-最大公约数"><a href="#H-最大公约数" class="headerlink" title="H. 最大公约数"></a>H. 最大公约数</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>有三个人，$A,B,C$，其中$A$和$B$共享了一个神秘的数字$k$，已知$1\le k\le n$。<br>现在$A$和$C$说：“$k$的值等于$x$”。<br>$C$不太信任$A$，于是想向$B$确认一下$k$是否真的等于$x$。$B$虽然不想直接把$k$的值告诉$C$，但是$B$允许$C$给出一个正整数$y$（注意$y$可以大于$n$），然后$B$会回答$gcd(k,y)$。<br>现在给出$k,n$，你需要帮助$C$决定这样的$y$的取值，使得$C$一定可以通过$B$的回答来判断$A$有没有撒谎。如果这样的$y$有多个，你需要输出最小的那个。</p></blockquote><h3 id="题目分析-7"><a href="#题目分析-7" class="headerlink" title="题目分析"></a>题目分析</h3><ol><li>$y$必须是$k$的倍数，否则无法区分$gcd(y,k)$和$k$。  </li><li>对于$[1,\lfloor\frac nk\rfloor]$的每一个质数$p$，$\frac yk$必须是$p$的倍数，否则无法区分$k$和$pk$。  </li><li>答案就是$k\prod p_i$，需要用高精度。  </li></ol><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><p>队友的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) (x)*(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100007</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1</span>&lt;&lt;<span class="number">29</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1007</span>][<span class="number">1007</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bignum</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> shu[<span class="number">300</span>];<span class="keyword">int</span> len;</span><br><span class="line">bignum()&#123;</span><br><span class="line"><span class="built_in">memset</span>(shu,<span class="number">0</span>,<span class="keyword">sizeof</span>(shu));</span><br><span class="line">&#125;</span><br><span class="line">bignum <span class="keyword">operator</span> = (<span class="keyword">int</span> a)&#123;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">30</span>];<span class="built_in">sprintf</span>(b+<span class="number">1</span>,<span class="string">"%d"</span>,a);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (bignum a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> len&lt;a.len;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=a.len;i;i--) <span class="keyword">if</span>(shu[i]!=a.shu[i]) <span class="keyword">return</span> shu[i]&lt;a.shu[i];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (bignum a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=a.len;i;i--) <span class="keyword">if</span>(shu[i]!=a.shu[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">bignum <span class="keyword">operator</span> = (<span class="keyword">char</span> *a)&#123;</span><br><span class="line">len=<span class="built_in">strlen</span>(a+<span class="number">1</span>);<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;a[i]==<span class="string">'0'</span>;i++) len--;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) shu[i]=a[len-i+<span class="number">1</span>]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (bignum a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;*<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(shu[i]&gt;<span class="number">9</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==len)&#123;</span><br><span class="line">shu[++len]=shu[i]/<span class="number">10</span>;</span><br><span class="line">shu[i]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> shu[i+<span class="number">1</span>]+=shu[i]/<span class="number">10</span>,shu[i]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bignum <span class="keyword">operator</span> + (bignum a)&#123;</span><br><span class="line"><span class="keyword">int</span> lm=max(len,a.len);bignum new1;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lm;i++)&#123;</span><br><span class="line">new1.shu[i]=shu[i]+a.shu[i];</span><br><span class="line">&#125;</span><br><span class="line">new1.len=lm;</span><br><span class="line">new1.move();</span><br><span class="line"><span class="keyword">return</span> new1;</span><br><span class="line">&#125;</span><br><span class="line">bignum <span class="keyword">operator</span> * (bignum a)&#123;</span><br><span class="line">bignum new1;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=a.len;k++)</span><br><span class="line">new1.shu[i+k<span class="number">-1</span>]+=shu[i]*a.shu[k];</span><br><span class="line">new1.len=len+a.len<span class="number">-1</span>;</span><br><span class="line">new1.move();</span><br><span class="line"><span class="keyword">return</span> new1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len;i;i--) <span class="built_in">printf</span>(<span class="string">"%d"</span>,shu[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>*i;k&lt;=<span class="number">1000</span>;k+=i)\</span><br><span class="line">vis[k]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t=read();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),m=read();</span><br><span class="line"><span class="keyword">int</span> x=m;bignum tot;tot=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">bignum now;now=i;</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i,tot=tot*now;</span><br><span class="line"><span class="keyword">if</span>(m*i&lt;=n) tot=tot*now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(m*i&lt;=n) tot=tot*now;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tot.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="I-K小数查询"><a href="#I-K小数查询" class="headerlink" title="I. K小数查询"></a>I. K小数查询</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>热爱学习刻苦奋斗的九条可怜最近做了很多数据结构题，接触到了$K$小数查询这一系列的问题以及线段树的重磅打击这一套理论，她觉得这两样东西都很厉害，所以想要出一道题。<br>给出一个长度为$n$的数列$A$，接下来有$m$次操作，操作有两种：</p><ul><li>$1\,l\,r\,x$，表示对$i\in[l,r]$，令$A_i=min(A_i,x)$</li><li>$2\,l\,r\,k$，表示询问区间$[l,r]$中第$k$小的数。<br>这个问题对可怜来说有点难，你能帮帮她吗。</li></ul></blockquote><h3 id="题目分析-8"><a href="#题目分析-8" class="headerlink" title="题目分析"></a>题目分析</h3><p>线段树套权值线段树，内部权值线段树需要可持久化处理。<br>也就是，对区间$[1,n]$建立线段树，对于每一个区间$[l,r]$建立一棵权值线段树保存每种权值出现了多少次。<br>这样询问可以转化为在$\log n$棵权值线段树上二分，询问可以在$O(\log^2n)$的时间内处理结束。<br>修改时，线段树先定位到一些结点区间$[l,r]$（这些区间的定位用到吉老师线段树定位,外部线段树的定位还是$\log n$的时间），将其内部权值线段树中$\ge x$的所有数并入$x$处，考虑暴力修改，可以转化为$t+1$次单点修改，$t$是被并入的结点个数，修改完权值线段树后，这$t+1$次修改需要向上维护，每一个父亲结点的权值线段树都需要重新合并，在可持久化后，这一段的时间复杂度是$O(t\log^2n)$。<br>接着在$[l,r]$这个区间打上已经取$\min$的标记，在标记下传时将比$x$更大的结点并入$x$。<br>时间复杂度的瓶颈在于$O(t\log^2n)$，每一次操作后内层线段树的叶子结点都会减少$t$，而$t$最多减少$n\log n$，所以$t\le n\log n$，本题时间复杂度为$O(n\log^3 n)$。  </p><p>但是这道题卡时间卡空间烦死了，到处要回收内存（所以写了两个merge）。  </p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">80005</span>,maxc=maxn*<span class="number">20</span>*<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; roots;</span><br><span class="line"><span class="keyword">int</span> n,m,top=<span class="number">0</span>,S[maxc];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Value_Tree &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> ls,rs,size;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;ls=rs=size=<span class="number">0</span>;&#125;</span><br><span class="line">Tree() &#123;clear();&#125;</span><br><span class="line">&#125; tree[maxc];</span><br><span class="line"><span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> !top?++size:S[top--];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;S[++top]=index;tree[index].clear();&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> val,<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!index)index=newnode();</span><br><span class="line">tree[index].size+=delta;</span><br><span class="line"><span class="keyword">if</span>(left==right)<span class="keyword">return</span> index;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(val&lt;=mid)tree[index].ls=insert(tree[index].ls,left,mid,val,delta);</span><br><span class="line"><span class="keyword">else</span> tree[index].rs=insert(tree[index].rs,mid+<span class="number">1</span>,right,val,delta);</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> val,<span class="keyword">int</span> delta=<span class="number">1</span>)</span> </span>&#123;<span class="keyword">return</span> insert(root,<span class="number">1</span>,n,val,delta);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">//将左右合并并可持久化</span></span><br><span class="line"><span class="keyword">if</span>(l==<span class="number">0</span>&amp;&amp;r==<span class="number">0</span>)<span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">int</span> index=newnode();</span><br><span class="line">tree[index].size=tree[l].size+tree[r].size;</span><br><span class="line">tree[index].ls=merge(tree[l].ls,tree[r].ls);</span><br><span class="line">tree[index].rs=merge(tree[l].rs,tree[r].rs);</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge2</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> del=<span class="number">0</span>)</span> </span>&#123; <span class="comment">//将右边并入左边并删除右边</span></span><br><span class="line"><span class="keyword">if</span>(r==<span class="number">0</span>)<span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">if</span>(l==<span class="number">0</span>)l=newnode();</span><br><span class="line">tree[l].size+=tree[r].size;</span><br><span class="line">tree[l].ls=merge2(tree[l].ls,tree[r].ls,del);</span><br><span class="line">tree[l].rs=merge2(tree[l].rs,tree[r].rs,del);</span><br><span class="line"><span class="keyword">if</span>(del)remove(r);</span><br><span class="line"><span class="keyword">if</span>(!del&amp;&amp;tree[l].size==<span class="number">0</span>) &#123;remove(l);<span class="keyword">return</span> <span class="number">0</span>;&#125; <span class="comment">//虚空子树不能删0结点，因为有负的贡献</span></span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!index)<span class="keyword">return</span>;</span><br><span class="line">remove(index);</span><br><span class="line">recycle(tree[index].ls);</span><br><span class="line">recycle(tree[index].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left==right)<span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> lsize=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> rt:roots)lsize+=tree[tree[rt].ls].size;</span><br><span class="line"><span class="keyword">if</span>(lsize&gt;=val) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;rt:roots)rt=tree[rt].ls;</span><br><span class="line"><span class="keyword">return</span> query(left,mid,val);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;rt:roots)rt=tree[rt].rs;</span><br><span class="line"><span class="keyword">return</span> query(mid+<span class="number">1</span>,right,val-lsize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segment_Tree &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> left,right,max,cnt,sec,lazy,root;</span><br><span class="line">Tree(<span class="keyword">int</span> l=<span class="number">0</span>,<span class="keyword">int</span> r=<span class="number">0</span>):left(l),right(r),max(<span class="number">0</span>),cnt(<span class="number">0</span>),sec(<span class="number">0</span>),lazy(INT_MAX),root(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; tree[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls index&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (index&lt;&lt;1)|1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[ls].max&gt;tree[rs].max) &#123;</span><br><span class="line">tree[index].max=tree[ls].max;</span><br><span class="line">tree[index].sec=max(tree[rs].max,tree[ls].sec);</span><br><span class="line">tree[index].cnt=tree[ls].cnt;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(tree[ls].max&lt;tree[rs].max) &#123;</span><br><span class="line">tree[index].max=tree[rs].max;</span><br><span class="line">tree[index].sec=max(tree[ls].max,tree[rs].sec);</span><br><span class="line">tree[index].cnt=tree[rs].cnt;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tree[index].max=tree[ls].max;</span><br><span class="line">tree[index].sec=max(tree[ls].sec,tree[rs].sec);</span><br><span class="line">tree[index].cnt=tree[ls].cnt+tree[rs].cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span> </span>&#123;</span><br><span class="line">tree[index]=Tree(Left,Right);</span><br><span class="line"><span class="keyword">if</span>(Left==Right) &#123;</span><br><span class="line">tree[index].max=a[Left];</span><br><span class="line">tree[index].cnt=<span class="number">1</span>;</span><br><span class="line">tree[index].root=Value_Tree::insert(tree[index].root,a[Left]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(Left+Right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,Left,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,Right);</span><br><span class="line">tree[index].root=Value_Tree::merge(tree[ls].root,tree[rs].root);</span><br><span class="line">push_up(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[index].max&lt;=val)<span class="keyword">return</span>;</span><br><span class="line">tree[index].root=Value_Tree::insert(tree[index].root,tree[index].max,-tree[index].cnt);</span><br><span class="line">tree[index].root=Value_Tree::insert(tree[index].root,val,tree[index].cnt);</span><br><span class="line">tree[index].max=val;</span><br><span class="line">tree[index].lazy=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[index].lazy==INT_MAX)<span class="keyword">return</span>;</span><br><span class="line">modify(ls,tree[index].lazy);</span><br><span class="line">modify(rs,tree[index].lazy);</span><br><span class="line">tree[index].lazy=INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Left&gt;tree[index].right||Right&lt;tree[index].left||tree[index].max&lt;val)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(Left&lt;=tree[index].left&amp;&amp;Right&gt;=tree[index].right&amp;&amp;tree[index].sec&lt;val) &#123;</span><br><span class="line"><span class="keyword">int</span> root=Value_Tree::insert(<span class="number">0</span>,tree[index].max,-tree[index].cnt); <span class="comment">//建立虚空树以便更新祖先信息</span></span><br><span class="line">root=Value_Tree::insert(root,val,tree[index].cnt);</span><br><span class="line">modify(index,val);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">push_down(index);</span><br><span class="line"><span class="keyword">int</span> root=Value_Tree::merge2(modify(ls,Left,Right,val),modify(rs,Left,Right,val),<span class="number">1</span>);</span><br><span class="line">tree[index].root=Value_Tree::merge2(tree[index].root,root);</span><br><span class="line">push_up(index);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Left&gt;tree[index].right||Right&lt;tree[index].left)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(Left&lt;=tree[index].left&amp;&amp;Right&gt;=tree[index].right) &#123;</span><br><span class="line">roots.push_back(tree[index].root);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">push_down(index);</span><br><span class="line">query(ls,Left,Right);</span><br><span class="line">query(rs,Left,Right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)a[i]=Get_Int();</span><br><span class="line">Segment_Tree::build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt=Get_Int(),l=Get_Int(),r=Get_Int(),v=Get_Int();</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>)Value_Tree::recycle(Segment_Tree::modify(<span class="number">1</span>,l,r,v));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">roots.clear();</span><br><span class="line">Segment_Tree::query(<span class="number">1</span>,l,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Value_Tree::query(<span class="number">1</span>,n,v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-德州扑克"><a href="#J-德州扑克" class="headerlink" title="J. 德州扑克"></a>J. 德州扑克</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>略</p><h3 id="题目分析-9"><a href="#题目分析-9" class="headerlink" title="题目分析"></a>题目分析</h3><p>枚举减枝，算了算了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;游记及总结在&lt;a href=&quot;https://www.zhihu.com/answer/972183481&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;逼乎&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;所有题目已更新。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://blog.bill.moe/categories/ACM/"/>
    
    
      <category term="贪心" scheme="https://blog.bill.moe/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="高斯消元" scheme="https://blog.bill.moe/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="矩阵树定理" scheme="https://blog.bill.moe/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
    
      <category term="线段树" scheme="https://blog.bill.moe/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="二分" scheme="https://blog.bill.moe/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="数论" scheme="https://blog.bill.moe/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="比赛酱油记" scheme="https://blog.bill.moe/tags/%E6%AF%94%E8%B5%9B%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
      <category term="高精度" scheme="https://blog.bill.moe/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
      <category term="segment_tree_beats" scheme="https://blog.bill.moe/tags/segment-tree-beats/"/>
    
      <category term="计算几何" scheme="https://blog.bill.moe/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>重庆第十届ACM市赛游记</title>
    <link href="https://blog.bill.moe/CQ-ACM-2019/"/>
    <id>https://blog.bill.moe/CQ-ACM-2019/</id>
    <published>2019-12-24T02:12:19.000Z</published>
    <updated>2019-12-24T02:58:33.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次打市赛，和两位学长组了个队，队名叫$100000007$，1e8+7。<br><blockquote class="blockquote-center"><ul><li>为什么要叫这个队名呀？</li><li><del>因为被这个取模坑过</del></li></ul></blockquote></p><a id="more"></a><h2 id="day-0"><a href="#day-0" class="headerlink" title="day 0"></a>day 0</h2><p>学院开迎新晚会，并没有什么时间准备。</p><h2 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h2><p>早上坐车来到学校，然后学校签到。<br>然而，我们学校，因为种种原因，并没有成功缴费。（震惊，当代985竟然交不起比赛报名费）<br>之后在志愿者小姐姐的指引下，让我们先参赛之后再进行缴费的流程。<br>拍了个照。<br><img src="/CQ-ACM-2019/1.jpg" alt><br>于是我们就去食堂吃午饭了。  </p><p>食堂太小了，里面人山人海，根本无法打饭，甚至找不到座位。<br>我们在食堂隔壁找了个座位聊了会天再去吃饭，终于排好队达到了饭发现社长让我们出去集合了。  </p><p>之后来到比赛机房，放好电脑手机，机房里每支队伍有4台电脑，但是主办方表示只有1台可以提交，但是每支队伍前后的空间很狭窄，对于讨论很不方便。<br>之后主办方又让我们只留一台电脑，其他的电脑关掉。smg。  </p><p>开始比赛后分工，A题是一道垃圾计数题，暴力或者打表都可以，于是开始打代码，队长打了个暴力调试花了18分钟，隔壁cyy只花了1min就过了，<del>是不是应该反省一下</del>。  </p><p>在队长打A题的时候，我在看H题，队友在看D题。<br>H题很快我出解了，就是一个贪心，但是代码很难写，先放在这儿。<br>D题队友给我们简单描述了下题意，很气的是，感觉就是个类似并查集的东西，但无论怎么想都会超时。  </p><p>A题过了后看了下榜，发现F题有很多人写，队友看了下题然后发现是道水题，于是就过去写A了。<br>我把H题想法告诉了队长，然后看了下B题cyy的珍珠奶茶，裸三角函数，于是也过去水过了，剩下的H题队长用了堆来写然后疯狂调试。  </p><p>然后就进入了自闭阶段。<br>D题感觉很奇怪没法得出合理的时间，C题感觉建模后跑类似最小生成树的东西，但是时间复杂度始终不对。<br>E题的题面甚至有锅，不过推了下样例懂了题意就没有反映上去，E题感觉是长链剖分后得到每个结点处的信息表，然后利用这个信息表求出题目所需要的答案，不过如何求出题目所需要的答案，我认为这应该是一个经典模型，不过没能推出来。<br>G题cyy买奶茶，可以想到是分数规划，不过我们发现$n$个点$n$条边，这是个基环树，需要对环进行展开然后做分数规划和树形Dp。  </p><p>终于，队长花了一大把时间把H题调过了，加入了思考。此时榜单上面有一个队伍过了G题，不过我忘了分数规划该怎么写<del>（根本没有复习）</del>，队长讲了一下过后我尝试写了一下，推了推样例发现有编号为$0$的点，这根本就不是基环树，就是一棵树！这是我们这次比赛最大的失误了，不过也有点坑，cyy别再喝奶茶了吧。  </p><p>当我们A掉G题后发现榜单登顶了，然后继续自闭。<br>C题模型转化后开始各种胡思乱想，然后队长发现自己读错题了<del>（不过并没有什么帮助）</del>。<br>最后半小时封榜，我们没能做出来，于是<del>诅咒</del>其他队伍也没有做出来的，最终成功拿到rank1。  </p><p>和出题人交流后，C题竟然就是个线段树，维护四个插头。D题是ST表加并查集（从没想过竟然可以这么做）。E题确实是长链剖分，然后可以推出结论上下一正一负的时候答案为$0$（完全推不出来）。  </p><h2 id="颁奖"><a href="#颁奖" class="headerlink" title="颁奖"></a>颁奖</h2><p>去年市赛rk1队伍人手一个平板，今年啥都没有，枯了。  </p><p>去了颁奖所在礼堂后竟然没有位置了，只好坐在最后面的台阶上摸鱼。<br><img src="/CQ-ACM-2019/2.jpg" alt><br><del>震惊，重庆大学代表队由于交不起报名费，颁奖典礼无处落座。</del></p><p>最终我们以1个特等奖，4个一等奖，3个二等奖，喜提团体第一。  </p><p>附一张队长帅照。<br><img src="/CQ-ACM-2019/3.jpg" alt><br><del>憨憨队长差点直接从礼仪手里把证书拿走</del></p><p>再接再厉吧，冬令营见。<del>（先苟过期末考再说）</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次打市赛，和两位学长组了个队，队名叫$100000007$，1e8+7。&lt;br&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;ul&gt;
&lt;li&gt;为什么要叫这个队名呀？&lt;/li&gt;
&lt;li&gt;&lt;del&gt;因为被这个取模坑过&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://blog.bill.moe/categories/ACM/"/>
    
    
      <category term="比赛酱油记" scheme="https://blog.bill.moe/tags/%E6%AF%94%E8%B5%9B%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>重大ACM社团市赛选拔赛 Round 2 题解</title>
    <link href="https://blog.bill.moe/CQU-Selection-2019-Round2/"/>
    <id>https://blog.bill.moe/CQU-Selection-2019-Round2/</id>
    <published>2019-12-08T06:46:47.000Z</published>
    <updated>2019-12-08T10:59:35.940Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Round 2的题目总体而言较难，对有基础的学生区分度较好。<br>题目难度系数：</p><ul><li>A : 3</li><li>B : 2</li><li>C : 4</li><li>D : 5</li><li>E : 4</li><li>F : 5</li><li>G : 1</li></ul><a id="more"></a><hr><h2 id="A-跳格子"><a href="#A-跳格子" class="headerlink" title="A.跳格子"></a><a href="http://94.191.85.166:8000/contest/4/problem/A" target="_blank" rel="noopener">A.跳格子</a></h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>建完图跑最小生成树即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Prim<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> from,to,dist;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> d,u;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (HeapNode a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> d&gt;a.d;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Prim</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n,ans,dist[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">bool</span> vst[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="keyword">this</span>-&gt;n=n;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">edges.push_back((Edge) &#123;from,to,dist&#125;);</span><br><span class="line"><span class="keyword">int</span> m=edges.size();</span><br><span class="line">G[from].push_back(m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)dist[i]=INT_MAX;</span><br><span class="line">priority_queue&lt;HeapNode&gt; Q;</span><br><span class="line">Q.push((HeapNode) &#123;</span><br><span class="line"><span class="number">0</span>,s</span><br><span class="line">&#125;);</span><br><span class="line">dist[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">HeapNode Now=Q.top();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">if</span>(vst[Now.u])<span class="keyword">continue</span>;</span><br><span class="line">vst[Now.u]=<span class="number">1</span>;</span><br><span class="line">ans+=dist[Now.u];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> id:G[Now.u]) &#123;</span><br><span class="line">Edge&amp; e=edges[id];</span><br><span class="line"><span class="keyword">int</span> Next=e.to,v=e.dist;</span><br><span class="line"><span class="keyword">if</span>(!vst[Next]&amp;&amp;v&lt;dist[Next]) &#123;</span><br><span class="line">dist[Next]=v;</span><br><span class="line">Q.push((HeapNode) &#123;</span><br><span class="line">dist[Next],Next</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125; prim;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (x<span class="number">-1</span>)*m+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)a[i][j]=Get_Int();</span><br><span class="line">prim.init(n*m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">prim.AddEdge(id(i,j),id(i+<span class="number">1</span>,j),-a[i][j]*a[i+<span class="number">1</span>][j]);</span><br><span class="line">prim.AddEdge(id(i+<span class="number">1</span>,j),id(i,j),-a[i][j]*a[i+<span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">prim.AddEdge(id(i,j),id(i,j+<span class="number">1</span>),-a[i][j]*a[i][j+<span class="number">1</span>]);</span><br><span class="line">prim.AddEdge(id(i,j+<span class="number">1</span>),id(i,j),-a[i][j]*a[i][j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,-prim.main(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Kruskal<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x - <span class="number">1</span>) * m + y - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;x,<span class="keyword">const</span> edge &amp;y) &#123;</span><br><span class="line"><span class="keyword">return</span> x.w &gt; y.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;e[<span class="number">2</span>*<span class="number">205</span>*<span class="number">205</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unionset</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">205</span>*<span class="number">205</span>];</span><br><span class="line">unionset() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">205</span>*<span class="number">205</span>;i++) f[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> f[x] = find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">f[find(x)] = find(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;us;</span><br><span class="line"><span class="keyword">int</span> ecnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != n) e[ecnt++] = (edge)&#123;id(i,j),id(i+<span class="number">1</span>,j),a[i][j]*a[i+<span class="number">1</span>][j]&#125;;</span><br><span class="line"><span class="keyword">if</span> (j != m) e[ecnt++] = (edge)&#123;id(i,j),id(i,j+<span class="number">1</span>),a[i][j]*a[i][j+<span class="number">1</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line">sort(e,e+ecnt);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ecnt &amp;&amp; cnt &lt; n*m;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!us.check(e[i].u,e[i].v)) &#123;</span><br><span class="line">us.uni(e[i].u,e[i].v);</span><br><span class="line">cnt ++;</span><br><span class="line">ans += e[i].w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="B-串串游戏"><a href="#B-串串游戏" class="headerlink" title="B.串串游戏"></a><a href="http://94.191.85.166:8000/contest/4/problem/B" target="_blank" rel="noopener">B.串串游戏</a></h2><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>一个简单的博弈论问题。<br>使用必胜必败态转移关系进行递推即可：  </p><ul><li>一个状态是必胜态当且仅当其后继状态包含一个必败态</li><li>一个状态是必败态当且仅当其后继状态均为必胜态</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>,maxm=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[maxm],f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(~f[n])<span class="keyword">return</span> f[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)<span class="keyword">if</span>(n&gt;=a[i]&amp;&amp;!Solve(n-a[i]))<span class="keyword">return</span> f[n]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> f[n]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)a[i]=Get_Int();</span><br><span class="line">fill(f,f+n+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(Solve(n))<span class="built_in">puts</span>(<span class="string">"xiaoqianglll"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Grafiore"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="C-滑稽树"><a href="#C-滑稽树" class="headerlink" title="C.滑稽树"></a><a href="http://94.191.85.166:8000/contest/4/problem/C" target="_blank" rel="noopener">C.滑稽树</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>求编号连续的区间的点在树上的最近公共祖先</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这道题有很多种做法。<br>首先需要敲一个LCA的板子，可以用倍增，可以用Dfs序。<br>如果用Dfs序，题目中有两种编号任意混淆，建议使用倍增。  </p><p>第一种做法：线段树合并LCA<br>用线段树维护区间的LCA，因为LCA有可并性，因此可以这样做，询问时直接查询对应区间即可。<br>时间复杂度是$O(n\log^2 n+q\log^2n)$，另外还包含线段树的巨大常数，可能需要卡常才能通过。  </p><p>第二种做法：Dfs序+RMQ+线段树<br>同样类似第一种做法，但使用Dfs序+RMQ来查询LCA，这样可以做到查询LCA只需要$O(1)$的时间。<br>然后建立线段树维护区间LCA，时间复杂度是$O(n\log n+q\log n)$。  </p><p>第三种做法：Tarjan求LCA<br>没有深究</p><p>第四种做法：两次ST表+RMQ<br>首先求出编号为$i$和编号为$i+1$的LCA。<br>考虑，区间$[x,y]$的LCA一定在区间中$[i,i+1]$的LCA列表中。<br>然后建立第二个ST表，将区间中深度更小的那一个LCA保存下来，使用RMQ回答询问。<br>时间复杂度是$O(n\log n+q)$</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>第一种做法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ni 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cerr&lt;&lt;#x&lt;&lt;<span class="meta-string">"="</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> q,l,r,x,y,k,ss[ni];</span><br><span class="line"><span class="keyword">int</span> vis[ni],f[ni][<span class="number">35</span>],fi[ni],p,n,a,b,deep[ni],s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">int</span> dat;</span><br><span class="line">&#125;t[<span class="number">1000000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to;</span><br><span class="line">&#125;w[ni];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> xx=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">xx=xx*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jiabian</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">w[++p].next=fi[x];</span><br><span class="line">w[p].to=y;</span><br><span class="line">fi[x]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;   vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=fi[u];i;i=w[i].next)</span><br><span class="line"><span class="keyword">if</span>(!vis[w[i].to])</span><br><span class="line">&#123;</span><br><span class="line">f[w[i].to][<span class="number">0</span>]=u;</span><br><span class="line">deep[w[i].to]=deep[u]+<span class="number">1</span>;</span><br><span class="line">dfs(w[i].to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[x]&lt;deep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(deep[f[x][i]]&gt;=deep[y])</span><br><span class="line">x=f[x][i];</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    <span class="keyword">if</span>(f[x][i]!=f[y][i])</span><br><span class="line">x=f[x][i],y=f[y][i];</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bulid</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[p].l=l;t[p].r=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">t[p].dat=l;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">bulid(p*<span class="number">2</span>,l,mid);</span><br><span class="line">bulid(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">t[p].dat=lca(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span>+<span class="number">1</span>].dat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;r&gt;=t[p].r)</span><br><span class="line">&#123;</span><br><span class="line">ss[++k]=t[p].dat;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) ask(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">// freopen("st.in","r",stdin);</span></span><br><span class="line">   <span class="comment">// freopen("st.out","w",stdout);</span></span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;   x=read();y=read();</span><br><span class="line">    jiabian(x,y);</span><br><span class="line">    jiabian(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    deep[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">30</span>;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    bulid(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    l=read();r=read();</span><br><span class="line">    k=<span class="number">0</span>;ask(<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">int</span> ak=ss[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=k;j++)</span><br><span class="line">    ak=lca(ak,ss[j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ak);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种做法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v,next;</span><br><span class="line">&#125;e[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> ecnt;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">e[ecnt].v = v;</span><br><span class="line">e[ecnt].next = head[u];</span><br><span class="line">head[u] = ecnt;</span><br><span class="line">ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> depth[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> node[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> first[maxn];</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">2</span>*maxn][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_RMQ</span><span class="params">(<span class="keyword">int</span> range)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=range;i++) st[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;pow2(j)&lt;=range;j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i+pow2(j)<span class="number">-1</span>&lt;range;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = st[i][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> r = st[i+pow2(j<span class="number">-1</span>)][j<span class="number">-1</span>];</span><br><span class="line">st[i][j] = depth[l] &lt; depth[r] ? l : r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;<span class="comment">//返回位置</span></span><br><span class="line"><span class="keyword">if</span> (u &gt; v) swap(u,v);</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">log</span>(v-u+<span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> l = st[u][k];</span><br><span class="line"><span class="keyword">int</span> r = st[v-pow2(k)+<span class="number">1</span>][k];</span><br><span class="line"><span class="keyword">return</span> depth[l] &lt; depth[r] ? l : r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> node[RMQ(first[u],first[v])];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">node[t] = u;</span><br><span class="line">depth[t] = d;</span><br><span class="line">first[u] = t;</span><br><span class="line">t++;</span><br><span class="line">vis[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=head[u];~i;i=e[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">DFS(v,d+<span class="number">1</span>);</span><br><span class="line">node[t] = u;</span><br><span class="line">depth[t] = d;</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Seg &#123;</span><br><span class="line"><span class="comment">//两倍空间公式 &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> node (l+r) | (l!=r)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l+r)/2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (l+mid) | (l != mid)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (mid+1+r) | (mid+1 != r)</span></span><br><span class="line"><span class="comment">//两倍空间公式 &#125;</span></span><br><span class="line"><span class="keyword">int</span> lca[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">lca[node] = l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">build(l,mid);</span><br><span class="line">build(mid+<span class="number">1</span>,r);</span><br><span class="line">lca[node] = LCA(lca[lson],lca[rson]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line"><span class="keyword">return</span> lca[node];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (R &lt;= mid) <span class="keyword">return</span> query(l,mid,L,R);</span><br><span class="line"><span class="keyword">if</span> (L &gt; mid) <span class="keyword">return</span> query(mid+<span class="number">1</span>,r,L,R);</span><br><span class="line"><span class="keyword">return</span> LCA(query(l,mid,L,R),query(mid+<span class="number">1</span>,r,L,R));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> node</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lson</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rson</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">AddEdge(u,v);</span><br><span class="line">AddEdge(v,u);</span><br><span class="line">&#125;</span><br><span class="line">DFS(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">init_RMQ(t);</span><br><span class="line">Seg::build(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">while</span> (m --) &#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Seg::query(<span class="number">1</span>,n,l,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四种做法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">300005</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,p[maxn][<span class="number">35</span>],f[maxn][<span class="number">35</span>],a[maxn],father[maxn],Depth[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;edges[x].push_back(y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sparse_Table</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=log2(n); j++)p[i][j]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)p[i][<span class="number">0</span>]=father[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=log2(n); j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">if</span>(p[i][j<span class="number">-1</span>]!=<span class="number">-1</span>)p[i][j]=p[p[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Depth[a]&lt;Depth[b])swap(a,b);</span><br><span class="line"><span class="keyword">int</span> k=log2(Depth[a]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(Depth[a]==Depth[b])<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(Depth[a]-(<span class="number">1</span>&lt;&lt;i)&gt;=Depth[b])a=p[a][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==b)<span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line"><span class="keyword">if</span>(p[a][i]!=<span class="number">-1</span>&amp;&amp;p[a][i]!=p[b][i]) &#123;</span><br><span class="line">a=p[a][i];</span><br><span class="line">b=p[b][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">Depth[Now]=depth;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edges[Now].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> Next=edges[Now][i];</span><br><span class="line"><span class="keyword">if</span>(Next==father[Now])<span class="keyword">continue</span>;</span><br><span class="line">father[Next]=Now;</span><br><span class="line">Dfs(Next,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sparse_Table2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)f[i][<span class="number">0</span>]=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j)&lt;n; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> L=f[i][j<span class="number">-1</span>],R=f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(Depth[L]&lt;Depth[R])f[i][j]=L;</span><br><span class="line"><span class="keyword">else</span> f[i][j]=R;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=log2(Right-Left+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> L=f[Left][x],R=f[Right-(<span class="number">1</span>&lt;&lt;x)+<span class="number">1</span>][x];</span><br><span class="line"><span class="keyword">if</span>(Depth[L]&lt;Depth[R])<span class="keyword">return</span> L;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),y=Get_Int();</span><br><span class="line">AddEdge(x,y);</span><br><span class="line">AddEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">father[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">Dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">Sparse_Table();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)a[i]=LCA(i,i+<span class="number">1</span>);</span><br><span class="line">Sparse_Table2();</span><br><span class="line">q=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=q; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),y=Get_Int();</span><br><span class="line"><span class="keyword">if</span>(x==y)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Query(x,y<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="D-cyy玩牌牌"><a href="#D-cyy玩牌牌" class="headerlink" title="D.cyy玩牌牌"></a><a href="http://94.191.85.166:8000/contest/4/problem/D" target="_blank" rel="noopener">D.cyy玩牌牌</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>cyy打牌有个习惯，他很喜欢打顺子。</p><p>顺子的定义是，3至5张序号连续且不重复的扑克牌。</p><p>现在他有了一堆扑克牌，他想考考你，是否存在一种方案，在只打顺子的情况下，能把这些牌打完？</p><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>首先需要注意到的是，$5$张以上的顺子都可以由$3,4,5$组成，所以对于顺子只需要要求它的长度大于$3$即可。<br>考虑差分，将区间减法转化为左端点减法与右端点加法。<br>差分后问题转化为正数与负数的匹配，利用左端点减一个数，右端点加同样的数，将差分序列全部变为$0$。<br>可以做一个匹配，但是写起来很复杂，可以乱搞一下简化代码。  </p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[maxn],b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b[<span class="number">2</span>]&lt;<span class="number">0</span>||b[<span class="number">3</span>]&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+<span class="number">3</span>&lt;=n; i++) &#123;</span><br><span class="line">sum+=(b[i]&gt;<span class="number">0</span>?b[i]:<span class="number">0</span>)+(b[i+<span class="number">3</span>]&lt;<span class="number">0</span>?b[i+<span class="number">3</span>]:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sum&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t&lt;=T; t++) &#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">a[i]=Get_Int();</span><br><span class="line">b[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">b[n+<span class="number">1</span>]=-a[n];</span><br><span class="line"><span class="keyword">if</span>(Check())<span class="built_in">printf</span>(<span class="string">"Case #%d: Yes\n"</span>,t);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case #%d: No\n"</span>,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="E-ytrsk的键盘"><a href="#E-ytrsk的键盘" class="headerlink" title="E.ytrsk的键盘"></a><a href="http://94.191.85.166:8000/contest/4/problem/E" target="_blank" rel="noopener">E.ytrsk的键盘</a></h2><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>显然，每一个键位只对应一个字符。<br>首先，搜索是阶乘级别的，显然是不可能的。<br>动规？在确定一个位置后是有后效性的，无法划分阶段。<br>$1\le m\le20$，这一个条件告诉我们，可以用二进制状态压缩来表示当前键盘按键的状态。  </p><p>不妨考虑贡献，统计某个字符$i$下一个字符是$j$的总数，每一次确定一个键位，就增加这么多总数的贡献。这些贡献由所有已经确定了键位的字符到所有还没有确定键位的字符构成，每一个的贡献均为$1$。<br>这样计算贡献，与原题的绝对值之和等价。  </p><p>因此设置状态$f(S)$表示键位确定状态为$S$时的贡献，枚举子集进行转移即可。<br>另外，由于状态的设置问题，统计相邻字符的时候下一个字符和上一个字符均需要统计。<br>详见代码1，时间复杂度为$O(2^m·m^2)$。  </p><p>这个时间复杂度还可以进行优化，我们可以事先统计出$g(S,i)$表示$S$状态中的已确定字符与未确定字符$i$构成的贡献。<br>$g(S,i)$可以通过lowbit转移，从而将时间复杂度优化到$O(2^m·m)$。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>代码一<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt[<span class="number">25</span>][<span class="number">25</span>],f[<span class="number">1</span>&lt;&lt;<span class="number">20</span>];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">cnt[s[i]-<span class="string">'a'</span>][s[i+<span class="number">1</span>]-<span class="string">'a'</span>]++;</span><br><span class="line">cnt[s[i+<span class="number">1</span>]-<span class="string">'a'</span>][s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">1</span>; S&lt;(<span class="number">1</span>&lt;&lt;m); S++) &#123;</span><br><span class="line">f[S]=INT_MAX/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;m; j++)<span class="keyword">if</span>(((S&gt;&gt;i)&amp;<span class="number">1</span>)^((S&gt;&gt;j)&amp;<span class="number">1</span>))sum+=cnt[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)<span class="keyword">if</span>((S&gt;&gt;i)&amp;<span class="number">1</span>)f[S]=min(f[S],f[S^(<span class="number">1</span>&lt;&lt;i)]+sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt[<span class="number">20</span>][<span class="number">20</span>],f[<span class="number">1</span>&lt;&lt;<span class="number">20</span>],g[<span class="number">1</span>&lt;&lt;<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) (i&amp;(-i))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">cnt[s[i]-<span class="string">'a'</span>][s[i+<span class="number">1</span>]-<span class="string">'a'</span>]++;</span><br><span class="line">cnt[s[i+<span class="number">1</span>]-<span class="string">'a'</span>][s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">1</span>; S&lt;(<span class="number">1</span>&lt;&lt;m); S++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)<span class="keyword">if</span>(!((S&gt;&gt;i)&amp;<span class="number">1</span>))g[S][i]=g[S^lowbit(S)][i]+cnt[(<span class="keyword">int</span>)log2(lowbit(S))][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">1</span>; S&lt;(<span class="number">1</span>&lt;&lt;m); S++) &#123;</span><br><span class="line">f[S]=INT_MAX/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)<span class="keyword">if</span>(!((S&gt;&gt;i)&amp;<span class="number">1</span>))sum+=g[S][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)<span class="keyword">if</span>((S&gt;&gt;i)&amp;<span class="number">1</span>)f[S]=min(f[S],f[S^(<span class="number">1</span>&lt;&lt;i)]+sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="F-小马过河"><a href="#F-小马过河" class="headerlink" title="F.小马过河"></a><a href="http://94.191.85.166:8000/contest/4/problem/F" target="_blank" rel="noopener">F.小马过河</a></h2><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>这显然是一个动态规划，首先不考虑方案数。<br>设置状态$f(x,y,0/1)$表示，河对岸有$x$条50kg的马，有$y$条100kg的马，船在河对岸还是在当前位置，此时的最少乘船次数。  </p><script type="math/tex; mode=display">f(x,y,1)=\min\{f(i,j,0)+1\}\quad,x\ge i,y\ge j</script><script type="math/tex; mode=display">f(x,y,0)=\min\{f(i,j,1)+1\}\quad,x\le i,y\le j</script><p>注意一下转移的条件，这个动规就完成了。  </p><p>然而并没有结束，怎么统计方案数呢？<br>我们用$g(x,y,0/1)$来表示方案数。<br>首先如果$f$在转移时发生了更新，$g$也应该重新更新。<br>如果$f$在转移时数据相同，$g$应该累加。<br>除此之外，由于相同体重的马是不一样的（带有标号的），还需要乘上对应的组合数，预处理一下杨辉三角即可。  </p><p>但是，这个动规的转移没有顺序性，不能使用递推来实现。<br>我们可以发现，虽然转移的阶段没有顺序性，但却有明显的层次，因此我们可以使用Bfs来转移动规，这也被称作记忆化搜索。（使用Dfs是错误的，想一想，为什么？）</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,K,a,b,f[<span class="number">55</span>][<span class="number">55</span>][<span class="number">2</span>];</span><br><span class="line">LL g[<span class="number">55</span>][<span class="number">55</span>][<span class="number">2</span>],C[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">bool</span> vst[<span class="number">55</span>][<span class="number">55</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,l;</span><br><span class="line">QueNode(<span class="keyword">int</span> xx=<span class="number">0</span>,<span class="keyword">int</span> yy=<span class="number">0</span>,<span class="keyword">int</span> ll=<span class="number">0</span>):x(xx),y(yy),l(ll) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;QueNode&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">g[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">vst[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">Q.push(QueNode(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">QueNode Now=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">int</span> x=Now.x,y=Now.y;</span><br><span class="line"><span class="keyword">if</span>(Now.l==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;=a; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=y; j&lt;=b; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>((i-x==<span class="number">0</span>&amp;&amp;j-y==<span class="number">0</span>)||(i-x)*<span class="number">50</span>+(j-y)*<span class="number">100</span>&gt;K)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(f[i][j][<span class="number">1</span>]&gt;f[x][y][<span class="number">0</span>]+<span class="number">1</span>) &#123;</span><br><span class="line">f[i][j][<span class="number">1</span>]=f[x][y][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">g[i][j][<span class="number">1</span>]=C[a-x][a-i]*C[b-y][b-j]%mod*g[x][y][<span class="number">0</span>]%mod;</span><br><span class="line"><span class="keyword">if</span>(!vst[i][j][<span class="number">1</span>]) &#123;</span><br><span class="line">vst[i][j][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">Q.push(QueNode(i,j,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f[i][j][<span class="number">1</span>]==f[x][y][<span class="number">0</span>]+<span class="number">1</span>)g[i][j][<span class="number">1</span>]=(g[i][j][<span class="number">1</span>]+C[a-x][a-i]*C[b-y][b-j]%mod*g[x][y][<span class="number">0</span>]%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=x; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=y; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>((x-i==<span class="number">0</span>&amp;&amp;y-j==<span class="number">0</span>)||(i-x)*<span class="number">50</span>+(j-y)*<span class="number">100</span>&gt;K)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(f[i][j][<span class="number">0</span>]&gt;f[x][y][<span class="number">1</span>]+<span class="number">1</span>) &#123;</span><br><span class="line">f[i][j][<span class="number">0</span>]=f[x][y][<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">g[i][j][<span class="number">0</span>]=C[x][i]*C[y][j]%mod*g[x][y][<span class="number">1</span>]%mod;</span><br><span class="line"><span class="keyword">if</span>(!vst[i][j][<span class="number">0</span>]) &#123;</span><br><span class="line">vst[i][j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">Q.push(QueNode(i,j,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f[i][j][<span class="number">0</span>]==f[x][y][<span class="number">1</span>]+<span class="number">1</span>)g[i][j][<span class="number">0</span>]=(g[i][j][<span class="number">0</span>]+C[x][i]*C[y][j]%mod*g[x][y][<span class="number">1</span>]%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">K=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)Get_Int()==<span class="number">50</span>?a++:b++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=a; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=b; j++)f[i][j][<span class="number">0</span>]=f[i][j][<span class="number">1</span>]=INT_MAX/<span class="number">2</span>;</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">C[i][<span class="number">0</span>]=C[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)C[i][j]=(C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">&#125;</span><br><span class="line">Dp();</span><br><span class="line"><span class="keyword">if</span>(f[a][b][<span class="number">1</span>]&lt;INT_MAX/<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">"%d\n%lld\n"</span>,f[a][b][<span class="number">1</span>],g[a][b][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1\n0"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="G-Accepted"><a href="#G-Accepted" class="headerlink" title="G.Accepted!"></a><a href="http://94.191.85.166:8000/contest/4/problem/G" target="_blank" rel="noopener">G.Accepted!</a></h2><h3 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h3><p>签到题，没过的同学请扇自己一巴掌。  </p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vst[maxn],flag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s;</span><br><span class="line">s=<span class="string">' '</span>+s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)<span class="keyword">if</span>(s[i]==<span class="string">'A'</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">'C'</span>) &#123;ans++;vst[i]=vst[i+<span class="number">1</span>]=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)<span class="keyword">if</span>(((s[i]==<span class="string">'A'</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">'A'</span>)||(s[i]==<span class="string">'C'</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">'C'</span>))&amp;&amp;!vst[i]&amp;&amp;!vst[i+<span class="number">1</span>])flag=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+flag);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Round 2的题目总体而言较难，对有基础的学生区分度较好。&lt;br&gt;题目难度系数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A : 3&lt;/li&gt;
&lt;li&gt;B : 2&lt;/li&gt;
&lt;li&gt;C : 4&lt;/li&gt;
&lt;li&gt;D : 5&lt;/li&gt;
&lt;li&gt;E : 4&lt;/li&gt;
&lt;li&gt;F : 5&lt;/li&gt;
&lt;li&gt;G : 1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://blog.bill.moe/categories/ACM/"/>
    
    
      <category term="动态规划" scheme="https://blog.bill.moe/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="最小生成树" scheme="https://blog.bill.moe/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="线段树" scheme="https://blog.bill.moe/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="状态压缩" scheme="https://blog.bill.moe/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="比赛酱油记" scheme="https://blog.bill.moe/tags/%E6%AF%94%E8%B5%9B%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
      <category term="博弈论" scheme="https://blog.bill.moe/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="RMQ" scheme="https://blog.bill.moe/tags/RMQ/"/>
    
      <category term="LCA" scheme="https://blog.bill.moe/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>重大ACM社团市赛选拔赛 Round 1 题解</title>
    <link href="https://blog.bill.moe/CQU-Selection-2019-Round1/"/>
    <id>https://blog.bill.moe/CQU-Selection-2019-Round1/</id>
    <published>2019-12-08T06:02:50.000Z</published>
    <updated>2019-12-08T07:31:10.744Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Round 1的题目总体而言不难，对19级新生区分度较好，E题略难，C题区间动规无人攻破实属遗憾。<br>题目难度系数：</p><ul><li>A : 1</li><li>B : 1</li><li>C : 4</li><li>D : 2</li><li>E : 6</li><li>F : 2</li></ul><a id="more"></a><hr><h2 id="A-走马"><a href="#A-走马" class="headerlink" title="A.走马"></a><a href="http://94.191.85.166:8000/contest/2/problem/A" target="_blank" rel="noopener">A.走马</a></h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>使用Bfs扩展马的路径即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;,dy[]= &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,f[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="keyword">bool</span> vst[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;pii&gt; Q;</span><br><span class="line">Q.push(mp(x,y));</span><br><span class="line">vst[x][y]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">pii Now=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">8</span>; i++) &#123;</span><br><span class="line">pii Next=mp(Now.first+dx[i],Now.second+dy[i]);</span><br><span class="line"><span class="keyword">if</span>(Next.first&lt;<span class="number">1</span>||Next.first&gt;n||Next.second&lt;<span class="number">1</span>||Next.second&gt;m||vst[Next.first][Next.second])<span class="keyword">continue</span>;</span><br><span class="line">Q.push(Next);</span><br><span class="line">vst[Next.first][Next.second]=<span class="number">1</span>;</span><br><span class="line">f[Next.first][Next.second]=f[Now.first][Now.second]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">m=Get_Int();</span><br><span class="line">x=Get_Int();</span><br><span class="line">y=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)f[i][j]=<span class="number">-1</span>;</span><br><span class="line">f[x][y]=<span class="number">0</span>;</span><br><span class="line">Bfs();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)<span class="built_in">printf</span>(<span class="string">"%d\t"</span>,f[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[i][m]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="B-Counting-Stars"><a href="#B-Counting-Stars" class="headerlink" title="B.Counting Stars"></a><a href="http://94.191.85.166:8000/contest/2/problem/B" target="_blank" rel="noopener">B.Counting Stars</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给一个区间和宽度W，求区间中宽度为W子区间的最大权值和。</p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>做一个前缀和，扫描一遍即可。<br>甚至有条件$P_i\le100000$，双指针都免了。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,w,a[maxn],sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">w=Get_Int();</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x=Get_Int(),y=Get_Int();</span><br><span class="line">a[x]+=y;</span><br><span class="line">m=max(m,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+w<span class="number">-1</span>&lt;=m; i++)ans=max(ans,sum[i+w<span class="number">-1</span>]-sum[i<span class="number">-1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="C-吸金石"><a href="#C-吸金石" class="headerlink" title="C.吸金石"></a><a href="http://94.191.85.166:8000/contest/2/problem/C" target="_blank" rel="noopener">C.吸金石</a></h2><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题竟然成了防AK题。（然而我写着写着就忘了自己的状态定义，似乎没资格说这句话）<br>首先，有几个结论是显然错误的，比如：</p><ol><li>浇水过程中，浇水的区间一定连续</li><li>每次选一个代价最小的浇水（局部贪心）</li></ol><p>常见的反例有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 1</span><br><span class="line">1 1000 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1000 1</span><br></pre></td></tr></table></figure></p><p>那怎么办呢？虽然浇水的区间不一定连续，但总可以划分成若干个区间，我们不妨想到区间DP：<br>设置状态$f(i,j)$表示浇完区间$[i,j]$的花的最小代价。<br>现在考虑将两个区间合并在一起进行转移。<br>枚举断点$k$，给$k$浇水，将区间$[i,k-1]和[k+1,j]$合并起来。  </p><script type="math/tex; mode=display">f(i,j)=f(i,k-1)+f(k+1,j)+w_{i,j,k}</script><p>其中$w_{i,j,k}$表示当前区间$[i,j]$，给$k$浇水的代价。</p><p>时间复杂度$O(n^3)$</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,w,a[<span class="number">405</span>],b[<span class="number">405</span>],t[<span class="number">405</span>],f[<span class="number">405</span>][<span class="number">405</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">w=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">a[i]=Get_Int();</span><br><span class="line">b[i]=Get_Int();</span><br><span class="line">t[i]=<span class="built_in">ceil</span>(<span class="keyword">double</span>(Get_Int())/w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>; len&lt;=n; len++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+len<span class="number">-1</span>&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">f[i][j]=INT_MAX/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i; k&lt;=j; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> l_cost=k<span class="number">-1</span>&gt;=i?f[i][k<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r_cost=k+<span class="number">1</span>&lt;=j?f[k+<span class="number">1</span>][j]:<span class="number">0</span>;</span><br><span class="line">f[i][j]=min(f[i][j],l_cost+r_cost+t[k]*(a[k]+b[i<span class="number">-1</span>]+b[j+<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[<span class="number">1</span>][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="D-triangle"><a href="#D-triangle" class="headerlink" title="D.triangle"></a><a href="http://94.191.85.166:8000/contest/2/problem/D" target="_blank" rel="noopener">D.triangle</a></h2><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>如果两个三角形相交，他们的结果一定相同，可以把它们合并起来，并集又可以和其他三角形相交。<br>因此想到并查集，于是这道题就很简单了。<br>枚举两两三角形，利用并查集合并，并查集内维护一个最右端点即可。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,L[maxn],R[maxn],father[maxn],f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (L[x]&lt;=L[y]&amp;&amp;R[x]&gt;=L[y]&amp;&amp;R[x]&lt;=R[y]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> father[x]==x?x:father[x]=Get(father[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx=Get(x),fy=Get(y);</span><br><span class="line"><span class="keyword">if</span>(fx!=fy) &#123;</span><br><span class="line">father[fx]=fy;</span><br><span class="line">f[fy]=max(f[fy],f[fx]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">L[i]=Get_Int();</span><br><span class="line">R[i]=Get_Int();</span><br><span class="line">f[i]=R[i];</span><br><span class="line">father[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line"><span class="keyword">if</span>(Check(i,j)||Check(j,i))Union(i,j);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[Get(i)]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="E-multiply"><a href="#E-multiply" class="headerlink" title="E.multiply"></a><a href="http://94.191.85.166:8000/contest/2/problem/E" target="_blank" rel="noopener">E.multiply</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>有一颗有$n$个节点的树，树的根节点固定为$1$，节点$i$的父节点为$P_i$，并且节点上带有权值$c_i$。</p><p>现在需要对于每一个$1$到$m$中的数$x$求出：树中有多少个连通块的乘积为$x$</p><p>因为答案过大，只需要输出$\mod 998244353$之后的数即可</p><h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>这是六道题中最难的一道题。<br>值得一提的是，数据太水了只判链也可以过。<br>首先这道题求连通块的信息，有点分治，点分树，边分治等经典做法。<br>在这里讲点分治的做法。<br>按照点分治的思路，提取出树的重心，考虑经过当前重心的连通块。<br>现在我们考虑乘积为$x$，这类似一个背包问题，有两种处理思路：</p><ol><li>自下而上统计信息，然后在重心处暴力合并或者启发式合并。</li><li>自上而下传递信息，然后再自下而上更新信息。</li></ol><p>对于连通块，一般采用第2种方式更为容易，第1种方式一般用于处理路径问题。<br>于是我们从重心向下访问子结点，每一个结点考虑转移子结点的方案数，这就类似一个背包问题。<br>预处理出每个数的约数表，这样我们可以在$O(nm\log n\log m)$的时间内完成本题。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>,maxm=<span class="number">4005</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,Core,Min,Size[maxn],Maxson[maxn],a[maxn];</span><br><span class="line">LL f[maxn][maxm],ans[maxm];</span><br><span class="line"><span class="keyword">bool</span> vst[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn],d[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Size</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">Size[Now]=<span class="number">1</span>;</span><br><span class="line">Maxson[Now]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">if</span>(Next==father||vst[Next])<span class="keyword">continue</span>;</span><br><span class="line">Get_Size(Next,Now);</span><br><span class="line">Size[Now]+=Size[Next];</span><br><span class="line">Maxson[Now]=max(Maxson[Now],Size[Next]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Core</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> father,<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">Maxson[Now]=max(Maxson[Now],Size[num]-Size[Now]);</span><br><span class="line"><span class="keyword">if</span>(Maxson[Now]&lt;Min) &#123;</span><br><span class="line">Min=Maxson[Now];</span><br><span class="line">Core=Now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">if</span>(Next==father||vst[Next])<span class="keyword">continue</span>;</span><br><span class="line">Get_Core(Next,Now,num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> fa,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v&gt;m)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)f[Now][i]=<span class="number">0</span>;</span><br><span class="line">f[Now][a[Now]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">if</span>(vst[Next]||Next==fa)<span class="keyword">continue</span>;</span><br><span class="line">Dfs(Next,Now,v*a[Next]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)tmp[j]=f[Now][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=a[Now]; j&lt;=m; j+=a[Now])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k:d[j/a[Now]])tmp[j]=(tmp[j]+f[Now][j/k]*f[Next][k]%mod)%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)f[Now][j]=tmp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">Min=n;</span><br><span class="line">Get_Size(Now,<span class="number">0</span>);</span><br><span class="line">Get_Core(Now,<span class="number">0</span>,Now);</span><br><span class="line">Now=Core;</span><br><span class="line">vst[Now]=<span class="number">1</span>;</span><br><span class="line">Dfs(Now,<span class="number">0</span>,a[Now]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)ans[i]=(ans[i]+f[Now][i])%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">if</span>(vst[Next])<span class="keyword">continue</span>;</span><br><span class="line">Solve(Next);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;edges[x].push_back(y);edges[y].push_back(x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=Get_Int();</span><br><span class="line">m=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)AddEdge(Get_Int(),i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)a[i]=Get_Int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; j++)<span class="keyword">if</span>(i%j==<span class="number">0</span>)d[i].push_back(j);</span><br><span class="line">Solve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="F-fraction"><a href="#F-fraction" class="headerlink" title="F.fraction"></a><a href="http://94.191.85.166:8000/contest/2/problem/F" target="_blank" rel="noopener">F.fraction</a></h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>将分数转化为连分数</p><h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目竟然没给出$n$的范围！连分数表示会不会停不下来导致$n$很大呢？<br>不会，考虑一下，我们每一次的操作：除法，取模，交换分子分母<br>这一个过程是不是类似辗转相除？<br>其实这就是辗转相除，因此连分数永远有有限解，并且时间复杂度与求$\gcd$一样都是$\log$级别。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cal</span><span class="params">(LL x,LL y)</span> </span>&#123;</span><br><span class="line">LL gcd=__gcd(x,y);</span><br><span class="line">x/=gcd;</span><br><span class="line">y/=gcd;</span><br><span class="line">ans.push_back(x/y);</span><br><span class="line"><span class="keyword">if</span>(x%y==<span class="number">1</span>) &#123;</span><br><span class="line">ans.push_back(y);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cal(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=Get_Int();</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line">ans.clear();</span><br><span class="line">LL a=Get_Int(),b=Get_Int();</span><br><span class="line">Cal(a,b);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ans.size()<span class="number">-1</span>; i++)<span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans.back());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Round 1的题目总体而言不难，对19级新生区分度较好，E题略难，C题区间动规无人攻破实属遗憾。&lt;br&gt;题目难度系数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A : 1&lt;/li&gt;
&lt;li&gt;B : 1&lt;/li&gt;
&lt;li&gt;C : 4&lt;/li&gt;
&lt;li&gt;D : 2&lt;/li&gt;
&lt;li&gt;E : 6&lt;/li&gt;
&lt;li&gt;F : 2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://blog.bill.moe/categories/ACM/"/>
    
    
      <category term="并查集" scheme="https://blog.bill.moe/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="动态规划" scheme="https://blog.bill.moe/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数学" scheme="https://blog.bill.moe/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="比赛酱油记" scheme="https://blog.bill.moe/tags/%E6%AF%94%E8%B5%9B%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
      <category term="Bfs" scheme="https://blog.bill.moe/tags/Bfs/"/>
    
      <category term="点分治" scheme="https://blog.bill.moe/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>「公告/悲报」评论回复邮件通知可能失效</title>
    <link href="https://blog.bill.moe/blog-info-1may/"/>
    <id>https://blog.bill.moe/blog-info-1may/</id>
    <published>2019-10-22T11:11:21.000Z</published>
    <updated>2019-10-22T12:32:25.740Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于Valine国内版加强了管理，要求应用绑定域名并备案（国外域名瑟瑟发抖），因此博客邮件通知可能会挂掉，请各位注意。  </p><p>另：应某网友建议，live2d添加了隐藏按钮。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Hexo" scheme="https://blog.bill.moe/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://blog.bill.moe/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>「菜鸟的自我修养」线性代数笔记</title>
    <link href="https://blog.bill.moe/linear-algebra/"/>
    <id>https://blog.bill.moe/linear-algebra/</id>
    <published>2019-10-21T08:31:00.000Z</published>
    <updated>2019-12-25T13:39:04.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记载了本菜鸟大学期间的线性代数笔记与总结（包括一些计算机延伸）。<br><div class="note warning">            <p>本文中的部分结论不给证明，证明请参考教材。</p>          </div></p><a id="more"></a><h1 id="一-行列式"><a href="#一-行列式" class="headerlink" title="一. 行列式"></a>一. 行列式</h1><h2 id="行列式的定义"><a href="#行列式的定义" class="headerlink" title="行列式的定义"></a>行列式的定义</h2><p>为了方便地表示$n$元一次方程组的解，行列式诞生了。<br>如二元一次方程组：</p><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2=b_1 \\a_{21}x_1+a_{22}x_2=b_2\end{cases}</script><p>其解可表示为：</p><script type="math/tex; mode=display">x_1=\frac{b_1a_{22}-b_2a_{12}}{a_{11}a_{22}-a_{12}a_{21}},\quad x_2=\frac{b_2a_{11}-b_1a_{21}}{a_{11}a_{22}-a_{12}a_{21}}</script><p>以上解的分母部分相同，可将其表示为行列式：</p><script type="math/tex; mode=display">\left|\begin{array}{cccc}     a_{11} & a_{12} \\    a_{21} & a_{22} \\\end{array}\right|=a_{11}a_{22}-a_{12}a_{21}</script><p>分子部分也可以表示成行列式，原解可以转化为：</p><script type="math/tex; mode=display">x_1=\frac{    \left|    \begin{array}{cccc}         b_{1} & a_{12} \\        b_{2} & a_{22} \\    \end{array}    \right|}{    \left|    \begin{array}{cccc}         a_{11} & a_{12} \\        a_{21} & a_{22} \\    \end{array}    \right|},\quadx_2=\frac{    \left|    \begin{array}{cccc}         a_{11} & b_{1} \\        a_{21} & b_{2} \\    \end{array}    \right|}{    \left|    \begin{array}{cccc}         a_{11} & a_{12} \\        a_{21} & a_{22} \\    \end{array}    \right|}</script><p>由上，二阶行列式的计算方法即为主对角线元素乘积减去反对角线元素乘积。<br>同理可以构造三元一次方程组并定义三阶行列式：</p><script type="math/tex; mode=display">\left|\begin{array}{cccc}     a_{11} & a_{12} & a_{13} \\    a_{21} & a_{22} & a_{23} \\    a_{31} & a_{32} & a_{33}\end{array}\right|=a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}-a_{13}a_{22}a_{31}</script><p>我们可以从中找到规律并得到$n$阶行列式的定义。<br>$n$阶行列式可以表示为$n!$个$n$项元素（不同行或不同列）相乘的代数和。<br>如何确定每一个乘积前面的正负号呢？<br>我们将这$n$个元素按照行数排序，观察它们的列数。<br>若列数组成的排列的逆序数（逆序对的个数）为奇数，则前面为负号，反之为正号。</p><p><strong>定义：对于一个$n$行$n$列的矩阵，作和数$\sum\limits_{p_1p_2\cdots p_n}(-1)^ta_{1p_1}a_{2p_2}\cdots a_{np_n}$，这里的$p_1p_2\cdots p_n$是自然数$1,2,\cdots,n$的一个排列，$t$是这个排列的逆序数，共$P_n=n!$项求和，称上述和式为这个$n$行$n$列矩阵形成的$n$阶行列式，记为：</strong></p><script type="math/tex; mode=display">\left|\begin{array}{cccc}    a_{11} & a_{12} & \cdots & a_{1n} \\    a_{21} & a_{22} & \cdots & a_{2n} \\    \vdots & \vdots &          & \vdots \\    a_{n1} & a_{n2} & \cdots & a_{nn}\end{array}\right|=det(a_{ij})=\sum_{p_1p_2\cdots p_n}(-1)^ta_{1p_1}a_{2p_2}\cdots a_{np_n}</script><p>$n$阶行列式同样可以表示为$\sum\limits_{p_1p_2\cdots p_n}(-1)^ta_{p_11}a_{p_22}\cdots a_{p_nn}$</p><h2 id="特殊的行列式"><a href="#特殊的行列式" class="headerlink" title="特殊的行列式"></a>特殊的行列式</h2><h3 id="对角行列式"><a href="#对角行列式" class="headerlink" title="对角行列式"></a>对角行列式</h3><p>除了对角线上的元其它元全为$0$的行列式。</p><script type="math/tex; mode=display">D=\left|\begin{array}{cccc}    \lambda_1 &   &   & 0 \\      & \lambda_2 &   &   \\      &   & \ddots &   \\    0 &   &   & \lambda_n \\\end{array}\right|=\prod_{i=1}^n\lambda_i</script><h3 id="反对角行列式"><a href="#反对角行列式" class="headerlink" title="反对角行列式"></a>反对角行列式</h3><p>除了反对角线上的元其它元全为$0$的行列式。</p><script type="math/tex; mode=display">D=\left|\begin{array}{cccc}    0 &   &   & \lambda_1 \\      &   & \lambda_2 &   \\      & \cdots &   &   \\    \lambda_n &   &   & 0 \\\end{array}\right|=(-1)^{\frac{n(n-1)}2}\prod_{i=1}^n\lambda_i</script><h3 id="三角形行列式"><a href="#三角形行列式" class="headerlink" title="三角形行列式"></a>三角形行列式</h3><p>若行列式满足当$i\gt j$时，$a_{ij}=0$，则称行列式为<strong>上三角行列式</strong><br>若行列式满足当$i\lt j$时，$a_{ij}=0$，则行列式称为<strong>下三角行列式</strong><br>三角形行列式的值为对角线上元的乘积。</p><h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><p>以对角线为对称轴，将行列式进行对称操作（行列互换，$a_{ij}\rightarrow a_{ji}$），转置后的行列式记作$D^{T}$，<strong>行列式值不变</strong>。<br>需要注意的是，转置并不是倒置。</p><script type="math/tex; mode=display">D=D^{T}</script><h3 id="互换行列"><a href="#互换行列" class="headerlink" title="互换行列"></a>互换行列</h3><p>互换行列式的两行或两列，<strong>行列式改变符号</strong>。<br>需要注意的是，这里与矩阵不同，矩阵在互换后其含义不变，而行列式会改变符号。<br>由此性质可以推导出，若行列式有相同的行或列，其值为$0$。</p><h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><p>行列式$D$的某一行或某一列都同乘一个数$k$后，<strong>行列式的值变为原来的$k$倍</strong>。<br>需要注意的是，这里与矩阵的数乘不同，矩阵数乘后每一个元均数乘。<br>由此可以对行列式进行提取公因数。</p><h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p>行列式若某一行或某一列的元都表示为两数之和，即可进行分解。</p><script type="math/tex; mode=display">D=\left|\begin{array}{cccc}    a_{11} & \cdots & a_{1,j-1} & b_{1j}+c_{1j} & a_{1,j+1} & \cdots & a_{1n} \\    a_{21} & \cdots & a_{2,j-1} & b_{2j}+c_{2j} & a_{2,j+1} & \cdots & a_{2n} \\    \vdots &   & \vdots & \vdots & \vdots &   & \vdots \\    a_{n1} & \cdots & a_{n,j-1} & b_{nj}+c_{nj} & a_{n,j+1} & \cdots & a_{nn}\end{array}\right|\\=\left|\begin{array}{cccc}    a_{11} & \cdots & a_{1,j-1} & b_{1j} & a_{1,j+1} & \cdots & a_{1n} \\    a_{21} & \cdots & a_{2,j-1} & b_{2j} & a_{2,j+1} & \cdots & a_{2n} \\    \vdots &   & \vdots & \vdots & \vdots &   & \vdots \\    a_{n1} & \cdots & a_{n,j-1} & b_{nj} & a_{n,j+1} & \cdots & a_{nn}\end{array}\right|\\+\left|\begin{array}{cccc}    a_{11} & \cdots & a_{1,j-1} & c_{1j} & a_{1,j+1} & \cdots & a_{1n} \\    a_{21} & \cdots & a_{2,j-1} & c_{2j} & a_{2,j+1} & \cdots & a_{2n} \\    \vdots &   & \vdots & \vdots & \vdots &   & \vdots \\    a_{n1} & \cdots & a_{n,j-1} & c_{nj} & a_{n,j+1} & \cdots & a_{nn}\end{array}\right|</script><h3 id="加成"><a href="#加成" class="headerlink" title="加成"></a>加成</h3><p>把行列式的某一行或某一列的各元同乘一个数后加到另一行或另一列对应元上，<strong>行列式不变</strong>。</p><h2 id="行列式的展开"><a href="#行列式的展开" class="headerlink" title="行列式的展开"></a>行列式的展开</h2><p>在$n$阶行列式$D=det(a_{ij})$中，把元$a_{ij}$所在的第$i$行与第$j$列划去，剩下元按原来的相对位置不变形成的一个$n-1$阶行列式称为$D$中元$a_{ij}$的<strong>余子式</strong>，记为$M_{ij}$，称$A_{ij}=(-1)^{i+j}M_{ij}$为$a_{ij}$的<strong>代数余子式</strong>。  </p><script type="math/tex; mode=display">D=\sum_{k=1}^{n}a_{ik}A_{ik}=\sum_{k=1}^{n}a_{kj}A_{kj}\quad(i,j=1,2,\cdots,n)</script><p>可以推导出：</p><script type="math/tex; mode=display">\sum_{k=1}^na_{ik}A_{jk}=\sum_{k=1}^na_{ki}A_{kj}=0</script><p>以及类似分块矩阵的性质：</p><script type="math/tex; mode=display">\begin{aligned}&\left|\begin{array}{cccc}    a_{11} & \cdots & a_{1k} & 0 & \cdots & 0 \\    \vdots &   & \vdots & \vdots &   & \vdots \\    a_{k1} & \cdots & a_{kk} & 0 & \cdots & 0 \\    c_{11} & \cdots & c_{1k} & b_{11} & \cdots & b_{1r} \\    \vdots &   & \vdots & \vdots &   & \vdots \\    c_{r1} & \cdots & c_{rk} & b_{r1} & \cdots & b_{rr}\end{array}\right|\\&=\left|\begin{array}{cccc}    A_{kk} & 0 \\    C_{rk} & B_{rr}\end{array}\right|\\&=\left|A\right|\left|B\right|\\&=\left|\begin{array}{cccc}    a_{11} & \cdots & a_{1k} \\    \vdots &   & \vdots \\    a_{k1} & \cdots & a_{kk}\end{array}\right|\left|\begin{array}{cccc}    b_{11} & \cdots & b_{1k} \\    \vdots &   & \vdots \\    b_{k1} & \cdots & b_{kk}\end{array}\right|\end{aligned}</script><h2 id="范德蒙德（Vandermonde）行列式"><a href="#范德蒙德（Vandermonde）行列式" class="headerlink" title="范德蒙德（Vandermonde）行列式"></a>范德蒙德（Vandermonde）行列式</h2><script type="math/tex; mode=display">D_n=\left|\begin{array}{cccc}    1 & 1 & \cdots & 1 \\    x_1 & x_2 & \cdots & x_n \\    x_1^2 & x_2^2 & \cdots & x_n^2 \\    \vdots & \vdots &   & \vdots \\    x_1^{n-1} & x_2^{n-1} & \cdots & x_n^{n-1}\end{array}\right|=\prod_{n\ge i\gt j\ge1}(x_i-x_j)</script><p>可以使用行列式的展开证明</p><h2 id="手算行列式"><a href="#手算行列式" class="headerlink" title="手算行列式"></a>手算行列式</h2><h3 id="三角化方法"><a href="#三角化方法" class="headerlink" title="三角化方法"></a>三角化方法</h3><p>通过行列式的性质将行列式化为三角形行列式，对角线乘积得解。</p><h3 id="展开法"><a href="#展开法" class="headerlink" title="展开法"></a>展开法</h3><p>将某一行某一列尽可能化为$0$，利用行列式的展开计算低阶行列式。</p><h3 id="递归法（数学归纳法）"><a href="#递归法（数学归纳法）" class="headerlink" title="递归法（数学归纳法）"></a>递归法（数学归纳法）</h3><p>找出$D_n$与低阶行列式间的关系，然后进行递归。</p><h3 id="镶边法"><a href="#镶边法" class="headerlink" title="镶边法"></a>镶边法</h3><p>给行列式加上一行和一列，构成$D_{n+1}$，保证$D_{n+1}=D_n$。<br>或给行列式加上一行和一列，构成范德蒙德行列式，利用待定系数法求解。</p><h3 id="拆分法"><a href="#拆分法" class="headerlink" title="拆分法"></a>拆分法</h3><p>利用行列式可分解的性质对行列式进行拆分。</p><h3 id="行和或者列和相等的行列式"><a href="#行和或者列和相等的行列式" class="headerlink" title="行和或者列和相等的行列式"></a>行和或者列和相等的行列式</h3><script type="math/tex; mode=display">\begin{aligned}& \left|\begin{array}{cccc}    a & b & b & \cdots & b \\    b & a & b & \cdots & b \\    b & b & a & \cdots & b \\    \vdots & \vdots & \vdots &   & \vdots \\    b & b & b & \cdots & a\end{array}\right| \\= &\left|\begin{array}{cccc}    a+(n-1)b & b & b & \cdots & b \\    a+(n-1)b & a & b & \cdots & b \\    a+(n-1)b & b & a & \cdots & b \\    \vdots & \vdots & \vdots &   & \vdots \\    a+(n-1)b & b & b & \cdots & a\end{array}\right| \\= & [a+(n-1)b]\left|\begin{array}{cccc}    1 & b & b & \cdots & b \\    1 & a & b & \cdots & b \\    1 & b & a & \cdots & b \\    \vdots & \vdots & \vdots &   & \vdots \\    1 & b & b & \cdots & a\end{array}\right| \\= & [a+(n-1)b]\left|\begin{array}{cccc}    1 & b & b & \cdots & b \\    0 & a-b & 0 & \cdots & 0 \\    0 & 0 & a-b & \cdots & 0 \\    \vdots & \vdots & \vdots &   & \vdots \\    0 & 0 & 0 & \cdots & a-b\end{array}\right| \\= & [a+(n-1)b](a-b)^{n-1}\end{aligned}</script><h3 id="爪型行列式"><a href="#爪型行列式" class="headerlink" title="爪型行列式"></a>爪型行列式</h3><p>在$a_i\neq0$时有：</p><script type="math/tex; mode=display">\begin{aligned}D_{n+1}= &\left|\begin{array}{cccc}    a_0 & b_1 & b_2 & \cdots & b_n \\    c_1 & a_1 &  &  &  \\    c_2 &  & a_2 &  &  \\    \vdots &  &  & \ddots &  \\    c_n &  &  &  & a_n\end{array}\right| \\= &\left|\begin{array}{cccc}    a_0-\frac{b_1c_1}{a_1} & 0 & b_2 & \cdots & b_n \\    c_1 & a_1 &  &  &  \\    c_2 &  & a_2 &  &  \\    \vdots &  &  & \ddots &  \\    c_n &  &  &  & a_n\end{array}\right| \\= &\left|\begin{array}{cccc}    a_0-\frac{b_1c_1}{a_1}-\frac{b_2c_2}{a_2} & 0 & 0 & \cdots & b_n \\    c_1 & a_1 &  &  &  \\    c_2 &  & a_2 &  &  \\    \vdots &  &  & \ddots &  \\    c_n &  &  &  & a_n\end{array}\right| \\= &\left|\begin{array}{cccc}    a_0-\sum\limits_{i=1}^n\frac{b_ic_i}{a_i} & 0 & 0 & \cdots & 0 \\    c_1 & a_1 &  &  &  \\    c_2 &  & a_2 &  &  \\    \vdots &  &  & \ddots &  \\    c_n &  &  &  & a_n\end{array}\right|= & (a_0-\sum\limits_{i=1}^n\frac{b_ic_i}{a_i})\prod_{i=1}^na_i\end{aligned}</script><h3 id="三对角行列式"><a href="#三对角行列式" class="headerlink" title="三对角行列式"></a>三对角行列式</h3><script type="math/tex; mode=display">D_n=\left|\begin{array}{cccc}    a & b &  &  &  \\    c & a & b &  &  \\      & c & a & \ddots &  \\      &   & \ddots & \ddots & b \\      &  &  & c & a\end{array}\right|</script><p>按第一行展开得：</p><script type="math/tex; mode=display">D_n=aD_{n-1}-bcD_{n-2}\quad(n\gt2)</script><p>其中$D_1=a,D_2=a^2-bc$<br>然后使用数列知识求解通解</p><h2 id="使用计算机求行列式"><a href="#使用计算机求行列式" class="headerlink" title="使用计算机求行列式"></a>使用计算机求行列式</h2><h3 id="使用定义计算"><a href="#使用定义计算" class="headerlink" title="使用定义计算"></a>使用定义计算</h3><p>枚举每一个排列，计算逆序数与元乘积，时间复杂度为$O(n\cdot n!)$。</p><h3 id="展开行列式计算"><a href="#展开行列式计算" class="headerlink" title="展开行列式计算"></a>展开行列式计算</h3><p>选中一行或一列，用其余行或列将其消至仅剩一个非零元，消去该元所在行列，变为$n-1$阶行列式递归计算。<br>较难单纯地用计算机实现，用计算机可以实现的最好方法同样也是下面一种方法。<br>理论时间复杂度为$O(n!^3)$（存疑）。</p><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>利用高斯消元，将行列式整理为三角形行列式或对角行列式，计算对角线的乘积即可。<br>时间复杂度$O(n^3)$。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文记载了本菜鸟大学期间的线性代数笔记与总结（包括一些计算机延伸）。&lt;br&gt;&lt;div class=&quot;note warning&quot;&gt;
            &lt;p&gt;本文中的部分结论不给证明，证明请参考教材。&lt;/p&gt;
          &lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="https://blog.bill.moe/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="学习笔记" scheme="https://blog.bill.moe/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Bill Yang 代码规范</title>
    <link href="https://blog.bill.moe/code-standard/"/>
    <id>https://blog.bill.moe/code-standard/</id>
    <published>2019-10-17T11:23:34.000Z</published>
    <updated>2019-10-21T08:33:29.925Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本代码规范为笔者所用的 C/C++ 代码编写格式规范，参考了 Java 的代码标准排版模式，并总结于此。</p><a id="more"></a><h2 id="换行与空格"><a href="#换行与空格" class="headerlink" title="换行与空格"></a>换行与空格</h2><p>笔者习惯在两段<strong>意义不同的代码块间</strong>进行换行。<br>并遵循<strong>不随意添加空行</strong>的原则。<br>如在头文件与宏与<code>using</code>段间添加空行，在函数间添加空行。<br>以下是范例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get_Int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL num=<span class="number">0</span>,bj=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> x=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(x)) &#123;<span class="keyword">if</span>(x==<span class="string">'-'</span>)bj=<span class="number">-1</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(x)) &#123;num=num*<span class="number">10</span>+x-<span class="string">'0'</span>;x=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> num*bj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50005</span>,K=<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linear_Bases</span> &#123;</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125; null;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line">LL a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> left,right;</span><br><span class="line">Linear_Bases lb;</span><br><span class="line">&#125; tree[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls index&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs index&lt;&lt;1|1</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>注：上述代码中宏未缩进为显示bug。</em></p><p>另，关于类与结构体中的成员函数，期间可以添加空行（提高可读性），也可以不添加空行（保证紧凑性），这里没有严格规范。</p><p>空格同样是用于提高代码可读性的。</p><p>正文与左大括号间添加空格。</p><blockquote><p>比较：左小括号与左中括号前不添加空格。</p></blockquote><p><strong>严禁在代码中添加大量无意义空格与空行。</strong>  </p><p>关于它们的使用，接下来的内容会详细描述。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure><p>多个头文件需要根据头文件的长度进行<strong>降序或升序排列</strong>（一般使用降序排列）</p><p>C++的代码在没有必要时，不使用<code>.h</code>结尾的头文件。<br>C的代码在没有必要时，不使用<code>c</code>开头的头文件。  </p><p>C++的代码推荐使用以下代码引用头文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>除上面一段以外，不推荐调用没有使用的头文件。  </p><p><strong>头文件间不添加空行与空格</strong></p><h2 id="宏与别名定义"><a href="#宏与别名定义" class="headerlink" title="宏与别名定义"></a>宏与别名定义</h2><p>一般，将宏与别名定义在头文件的下方，代码正文的上方。<br>全局宏与非自定义宏，请遵循上述原则。<br>特殊情况：</p><ol><li>仅在某个代码块使用到的宏与别名，可以在代码块上部定义，位于代码块正文上方，代码块变量定义下方。  </li><li>条件编译开关等编译相关宏不遵循以上原则，若无必要的位置，尽量置于头文件上方。</li></ol><p>在代码块中的宏，保持<strong>代码缩进</strong>。<br>宏与别的代码块间，添加空行。</p><p>如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OnlineJudge</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Balance_Tree</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; tree[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls tree[x].child[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs tree[x].child[1]</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"debugging"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码块及命名空间"><a href="#代码块及命名空间" class="headerlink" title="代码块及命名空间"></a>代码块及命名空间</h2><p>支持的代码块格式有以下两种：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">//这是代码缩进</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="built_in">puts</span>(<span class="string">"..."</span>);&#125; <span class="comment">//这里没有缩进</span></span><br></pre></td></tr></table></figure><p>使用命名空间的时候，在使用的代码块前添加：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> xxx;</span><br></pre></td></tr></table></figure></p><p>特别地，在使用std的时候，将代码提前到头文件后，宏定义与变量定义前。</p><p>在编写命名空间时，添加左括号前的空格与代码缩进。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> name1 &#123;</span><br><span class="line"><span class="comment">//这是代码缩进</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> name1;</span><br></pre></td></tr></table></figure></p><p>命名空间应遵循黑箱原则，即：命名空间所使用的变量与常量均应在命名空间内定义，命名空间使用到的外部量只能通过传参方式完成。</p><p>命名空间内应与命名空间外遵循同样的原则。</p><h2 id="结构体-类"><a href="#结构体-类" class="headerlink" title="结构体/类"></a>结构体/类</h2><p><em>在OI中，我们常常使用结构体实现简易类。</em>  </p><p>遵循黑箱原则。</p><p>结构体类似命名空间，特别的，结构体内的成员函数间可不添加空行。</p><p>类中包含的<code>public</code>，<code>private</code>等关键词应保持缩进，与成员变量或函数间不添加空行，但在不同的关键词间应保持空行，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increaseAge</span><span class="params">()</span> </span>&#123;age++;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>关于重载，在符号前后添加空格，尽量使用常量引用传参，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> Matrix &amp;b) &#123;</span><br><span class="line">Matrix c=*<span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="引用符-amp"><a href="#引用符-amp" class="headerlink" title="引用符&amp;"></a>引用符&amp;</h2><p><code>&amp;</code>一般添加在变量名前：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;x=y;</span><br></pre></td></tr></table></figure></p><h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>传参可使用三种方式传参，格式分别如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>;</span><br></pre></td></tr></table></figure></p><p>逗号前后不添加空格。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>非<code>void</code>函数需要保证函数必定有退出出口，即该函数在任意情况下都能退出。</p><p>函数的两种格式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="if-else嵌套"><a href="#if-else嵌套" class="headerlink" title="if-else嵌套"></a>if-else嵌套</h2><p>保持代码缩进。<br>大括号与正文间添加空格。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一种格式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)<span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)<span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"3"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"4"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>在分号之后添加一个空格，不添加其他任何空格。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++,x++) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(; i&lt;=n; i++) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(; i&lt;=n; ) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>若仅有限制条件的循环，不建议使用for循环。</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>不添加多余空格。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果想到新内容还会更新的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本代码规范为笔者所用的 C/C++ 代码编写格式规范，参考了 Java 的代码标准排版模式，并总结于此。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="https://blog.bill.moe/categories/OI/"/>
    
    
      <category term="学习笔记" scheme="https://blog.bill.moe/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="科普" scheme="https://blog.bill.moe/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>「有趣的数学」神奇的自然底数$e$</title>
    <link href="https://blog.bill.moe/magical-e/"/>
    <id>https://blog.bill.moe/magical-e/</id>
    <published>2019-09-04T02:34:53.000Z</published>
    <updated>2019-12-03T12:06:24.641Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有关于自然底数$e$的概念我们是在学习基本初等函数时了解的，可惜的是，高中教材并没有给我们详细的阐述有关$e$的概念与优美的性质，大家普遍只知道它是一个无理数。<br>于是我们常常听到这样的话：“常用底数不常用，自然底数不自然。”<br>那么为什么$10$被称为常用底数，$e$被称为自然底数呢？<br>不要急，请容我娓娓道来。<br><a id="more"></a></p><h2 id="对数的发明"><a href="#对数的发明" class="headerlink" title="对数的发明"></a>对数的发明</h2><blockquote><p>16、17世纪之交，天文学极速发展，但由于天文学数字总是非常大，计算起来很不方便，因此人们迫切的想要找到一种简化数字计算的方法。<br>天文学家约翰·纳皮尔为了简化运算发明了对数，最初的定义是通过运动学阐述的，后来与朋友布里格斯商定，使$1$的对数为$0$，$10$的对数为$1$，这样就得到了以$10$为底的常用对数。</p></blockquote><p>我们发现，之所以称$10$为常用底数正是因为它被广泛运用到天文学中。</p><p>值得一提的是，我们都知道对数与指数是互逆关系，但对数比指数的发明更早，直到18世纪欧拉才发现了它们的互逆关系，这也成为了数学史上的佳话。</p><h2 id="e-的发现"><a href="#e-的发现" class="headerlink" title="$e$的发现"></a>$e$的发现</h2><p>我们介绍了对数的发明，那么自然底数是如何被发现的呢？神奇的是，自然底数的发现却与对数没有关系。<br>在17世纪末，瑞士数学家伯努利注意到了一个有趣的现象：当$x$越大时，$\Big(1+\frac1x\Big)^x$将会越接近某个固定的数：</p><script type="math/tex; mode=display">\Big(1+\frac1{100}\Big)^{100}\approx 2.70481</script><script type="math/tex; mode=display">\Big(1+\frac1{1000}\Big)^{1000}\approx 2.71692</script><script type="math/tex; mode=display">\Big(1+\frac1{10000}\Big)^{10000}\approx 2.71815</script><p>18世纪欧拉（没错又是欧拉）仔细研究了这个问题，并第一次使用字母$e$来表示当$x$无穷大时$\Big(1+\frac1x\Big)^x$的值，即：</p><script type="math/tex; mode=display">\lim_{x\rightarrow\infty}\Big(1+\frac1x\Big)^x=e</script><p>欧拉不仅求出了$e\approx2.718$，还证明了$e$是无理数。<br>那么$e$究竟有什么神奇的性质呢？</p><h2 id="神奇的-e"><a href="#神奇的-e" class="headerlink" title="神奇的$e$"></a>神奇的$e$</h2><h3 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h3><p>在高二我们会学习到指数函数的导数。</p><script type="math/tex; mode=display">(e^x)'=e^x</script><p>即$e^x$的导数是他的本身。<br>正因为有这样的性质，故指数函数在我们现实世界中具有重要作用。<br>当我们涉及到一个量的变化与自身大小相关的问题时，就往往需要引入指数函数或对数函数。</p><h3 id="连续复利公式"><a href="#连续复利公式" class="headerlink" title="连续复利公式"></a>连续复利公式</h3><p>假设有一家银行，年利率是$5\%$，并且每时每刻都在结算利息。<br>如果我们存入$1w$元，下一年我们就可以获得$500$元的利息，但这并不是能让我们获得最大收益的方法。<br>我们可以半年后取出利息，再把本金和利息重新作为本金计算，这样我们下半年可以获得$(1w+250)\times2.5\%=256.25$元的利息，也就是说我们最后的总利息是$506.25$元。<br>如果我们一个季度取出一次利息，那么获得的利息会更多。<br>随着我们逐渐缩短我们存取的间隔，利益会越来越大，当我们将存取的间隔缩短到无穷小时，获得的利益最大，此时就是连续复利。<br>可惜的是，我们并不能通过这样的方式赚到很多的钱，因为缩短间隔过程中利息的增多是收敛的，而连续复利就是它们的极限。<br>那么我们究竟能赚到多少钱呢？<br>设本金是$p_0$，年利率是$i$，每年的结算期数是$m$（每年存取的次数）。</p><script type="math/tex; mode=display">p_{nm}=p_0(1+\frac im)^{mn}</script><p>当$m\rightarrow\infty$时：</p><script type="math/tex; mode=display">p_n=\lim_{m\rightarrow\infty}p_0(1+\frac im)^{mn}=p_0\lim_{m\rightarrow\infty}[(1+\frac im)^{\frac mi}]^{ni}=p_0e^{ni}</script><p>上述公式即是连续复利公式。<br>当年利率是$5\%$，我们通过连续复利可以得到的利息约为$512.7$元，可见增加的利益也并不可观。</p><h3 id="e-x-的泰勒展开"><a href="#e-x-的泰勒展开" class="headerlink" title="$e^x$的泰勒展开"></a>$e^x$的泰勒展开</h3><p>对$e^x$<a href="/taylor-series-notes/">泰勒展开</a>，得到：</p><script type="math/tex; mode=display">e^x=\sum_{i=0}^{\infty}\frac{x^i}{i!}</script><p>这个公式又被称为麦克劳林公式。</p><h3 id="复分析下的欧拉公式"><a href="#复分析下的欧拉公式" class="headerlink" title="复分析下的欧拉公式"></a>复分析下的欧拉公式</h3><p>我们先来看看欧拉恒等式：</p><script type="math/tex; mode=display">e^{i\pi}+1=0</script><p>它是数学里最令人着迷的公式之一，它将数学里最重要的几个常数联系到了一起：两个超越数：自然底数$e$，圆周率$π$，两个单位：虚数单位$i$和自然数的单位$1$，以及数学里常见的$0$。因此，数学家们评价它是“上帝创造的公式，我们只能看它而不能理解它。”<br>欧拉恒等式是复分析下的欧拉公式的一个特例，欧拉公式如下：</p><script type="math/tex; mode=display">e^{ix}=\cos x+i\sin x</script><p>当代入$x=\pi$时即得到欧拉恒等式。<br>我们在<a href="/fast-fourier-transform-notes/">傅里叶变换</a>中提到过这一个欧拉公式，它使我们可以通过函数的方式来描述一个复数。<br>现在要介绍的是欧拉公式的推导：<br>我们将麦克劳林公式中的$x$替换为$ix$，即可得到：</p><script type="math/tex; mode=display">\begin{aligned}e^x&=1+ix+\frac{(ix)^2}{2!}+\frac{(ix)^3}{3!}+\frac{(ix)^4}{4!}+\cdots \\&=1+ix-\frac{x^2}{2!}-\frac{ix^3}{3!}+\frac{x^4}{4!}+\cdots\end{aligned}</script><p>我们把不含$i$的放一边，含$i$的放在另一边，则可以得到：</p><script type="math/tex; mode=display">\begin{aligned}e^x&=(1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdots)+i(x-\frac{x^3}{3!}+\frac{x^5}{5!}-\cdots) \\&=\cos x+i\sin x\end{aligned}</script><h3 id="杨辉三角（摘自-Matrix67-的博客）"><a href="#杨辉三角（摘自-Matrix67-的博客）" class="headerlink" title="杨辉三角（摘自 Matrix67 的博客）"></a>杨辉三角（摘自 Matrix67 的博客）</h3><p>你相信吗，杨辉三角里竟然也有自然底数 e 的身影。2012 年， Harlan Brothers 发现了杨辉三角中的一个有趣的事实。不妨把杨辉三角第$n$行的所有数之积记作$s_n$，那么随着$n$的增加，$\frac{s_ns_{n+2}}{s_{n+1}^2}$会越来越接近$e\approx 2.718$。事实上，我们有：</p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}\frac{s_ns_{n+2}}{s_{n+1}^2}=e</script><p>这是为什么呢？ John Baez 在<a href="http://johncarlosbaez.wordpress.com/2014/02/12/triangular-numbers/" target="_blank" rel="noopener">这个网页</a>上给出了一个漂亮的解释。</p><p><img src="/magical-e/1.png" alt></p><p>首先，让杨辉三角 (A) 里面的每个数都除以它左下角的那个数，于是得到了图 (B) 所示的三角形数阵。你会发现，这个数阵里有一个很明显的模式，即第$n$行的所有数分母都是$n$，分子则分别是$n,n-1,\ldots,2,1$。这并不是巧合。这是因为：</p><script type="math/tex; mode=display">\frac{C_m^k}{C_{m+1}^k}=\frac{\frac{m!}{k!(m-k)!}}{\frac{(m+1)!}{k!(m-k+1)!}}=\frac{m-k+1}{m+1}</script><p>接下来，让图 (B) 里的所有数都除以它右下角的那个数，于是得到了图 (C) 所示的三角形数阵。容易看出，这个数阵第$n$行的所有$n$个数应该都是$\frac{n+1}{n}=1+\frac1n$ ，它们乘起来等于$(1+\frac1n)^n$。随着$n$的增加，这个数会越来越接近$e$。最后，让我们追溯一下图 (C) 中每个数的来源。图 (C) 中第$n$行的每个数都等于图 (B) 中第$n$行的某个数除以第$n+1$行的某个数，进而等于图 (A) 中第$n$行的某个数除以第$n+1$行的某个数的结果，除以第$n+1$行的某个数除以第$n+2$行的某个数的结果。因此，图 (C) 中第$n$行的所有数乘起来，结果正是$\frac{s_ns_{n+2}}{s_{n+1}^2}$。</p><p>我们称$e$为自然底数，正是因为它有这些神奇的性质，就像是自然创造出来的一个神奇常数。<br>也正是如此，$e$被广泛运用到数学和信息学之中，欢迎读者补充以上内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有关于自然底数$e$的概念我们是在学习基本初等函数时了解的，可惜的是，高中教材并没有给我们详细的阐述有关$e$的概念与优美的性质，大家普遍只知道它是一个无理数。&lt;br&gt;于是我们常常听到这样的话：“常用底数不常用，自然底数不自然。”&lt;br&gt;那么为什么$10$被称为常用底数，$e$被称为自然底数呢？&lt;br&gt;不要急，请容我娓娓道来。&lt;br&gt;
    
    </summary>
    
      <category term="科普" scheme="https://blog.bill.moe/categories/%E7%A7%91%E6%99%AE/"/>
    
    
      <category term="科普" scheme="https://blog.bill.moe/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>近期香港机场相关个人评论</title>
    <link href="https://blog.bill.moe/HongKongAirline/"/>
    <id>https://blog.bill.moe/HongKongAirline/</id>
    <published>2019-08-14T07:00:46.000Z</published>
    <updated>2019-08-18T01:20:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>众所周知，香港近期发生了严重的骚乱，然而不巧的是，本人去日本旅行刚好往返均需要在香港转机，因此笔者目睹了香港机场的状况并持续关注，现在将我的经历与评论记录在此。</p><a id="more"></a><p>本人的预定行程如下：<br><img src="/HongKongAirline/0.png" alt><br>国际航班需要提前三小时到达机场，因此我们5点钟就要到达机场，4点钟起床，妙啊。<br><img src="/HongKongAirline/1.jpg" alt><br>HX497顺利起飞并达到香港机场。<br><img src="/HongKongAirline/2.jpg" alt><br><img src="/HongKongAirline/3.jpg" alt><br><img src="/HongKongAirline/4.jpg" alt><br>抵达香港机场后，需要机场巴士将我们载到候机厅，我们等待了1个小时左右，原因是：“机场繁忙”<br>由于距离下午5点钟飞大阪的航班还有相当长的一段时间，经过耐心等候后开始办理转机手续，就在这时，问题出现了，8月5日飞往大阪的航班HX612取消。<br>为什么航班会取消呢？翻看新闻后发现：<br><img src="/HongKongAirline/4.5.png" alt><br>计划8月5日开始罢工？真巧，撞车了。<br>港航工作人员告诉我们，需要乘坐机场的小火车到达客运大楼并询问他们处理方法，而客运大楼港航前台工作人员告知我们需要出海关并在海关外出票柜台办理改签。<br>于是呢，我们就只有出海关了。当我们终于找到改签柜台时，发现了柜台盛况：<br><img src="/HongKongAirline/5.jpg" alt><br>（照相时已经排队2小时，排队的大概有数百人）<br>这是我至今为止排过的最长的队（然而不久就被C96的排队规模突破记录了）<br>香港航空仅有3个柜台在服务中，然而他们一个人一个人接待，改签，道歉，实属不易。这里我要吹爆港航，虽然港航是一家仅有34架空客的公司，但是香港航空的员工们尽职尽责，<a href="https://baijiahao.baidu.com/s?id=1641714847066448721&amp;wfr=spider" target="_blank" rel="noopener">态度明确</a>，全力帮助乘客解决问题。反观隔壁国泰航空，煽动罢工暴乱，让其他航空公司帮他们擦屁股。<br>经过与港航小姐姐的协调后，我们改签至第二天的航班（仍然是HX612，但变成了一架小飞机），但是仍然不知道改签航班是否会取消，以下是港航小姐姐的笔迹：<br><img src="/HongKongAirline/7.jpg" alt><br>因此我们只好改变行程，并在机场度过一晚（为什么不出机场找酒店？我敢去吗）。为了保持联络，我们需要找到充电插座，然而所有的机场充电插座都被占用了，无奈之下，我们只好等待麦当劳的充电座位出现空位。<br>当天，示威游行群众就在我们楼下，与我们所处地点之间完全没有障碍。<br><img src="/HongKongAirline/6.jpg" alt><br>于是我们在麦当劳度过了难忘的一晚，原计划是轮流睡觉照看行李，结果变成了两人一起看权游然后压着包睡觉但是睡不着，最终我们顺利完成了1小时精致睡眠然后继续待机（看权游）。<br>香港机场这里的吃喝都比较贵，所以我们早中晚都是吃的麦当劳（稍微便宜一点），我们总共吃了5顿麦当劳，吃到我肚子不舒服，整个人都不好了。<br><img src="/img/sentence/hyc10.png" alt><br>8月6日下午2点，我们顺利拿到了登机牌。<br><img src="/HongKongAirline/8.jpg" alt><br>今天示威的群众似乎稍微消停了会儿，于是我们顺利登机并到达大阪。<br><img src="/HongKongAirline/9.jpg" alt><br>值得一提的是，与我们一起从重庆出发并在香港转机前往大阪的还有一个（看似）教育机构组织的游学，他们穿着蓝色T恤。据了解，他们乘坐第一天晚上前往东京的飞机离开了，然而我们就没这么幸运了，酒店与行程是已经预定好了的，我们只能前往大阪（同时第一天的行程还泡汤了）。<br>幸运的是，第二天的行程没有泡汤，并顺利地听到了 ほんまに（关西话）。</p><p>接下来就是在霓虹度过的愉快的一周。</p><p>然后8月13日返程，此时HK仍然很不安稳，我们考虑过其他直飞航班，但是从东京成田直飞重庆机票价格上万，于是放弃了。<br>接下来发生的事非常精彩。<br><img src="/HongKongAirline/10.jpg" alt><br>我们于成田空港顺利起飞并到达香港，咨询香港航空后得到需要在起飞3小时前才能确认航班是否取消，目前取消的航班仅有几个。<br>但当我们等到下午时，其他网友告诉我们航班全部取消了。<br><img src="/HongKongAirline/11.jpg" alt><br><img src="/HongKongAirline/12.jpg" alt><br>然而此时机场中我们的公示牌情况为：<br><img src="/HongKongAirline/13.jpg" alt><br>确实取消了一些航班，但并未全部取消，工作人员告知我们目前一切正常，航班并未取消，因此我认为可能是假新闻，于是没在意太多，5点钟左右时，我乘坐小火车前往客运大楼吃晚饭（因为转机候机厅没有餐厅），行李由同行朋友照看。<br>当我吃完饭准备返回候机厅时问题出现了，我回不去了。需要出示登机牌才能进入候机厅，然而我们的航班尚不能打印登机牌，而且我什么都没有带过来。<br>于是我只好拜托我的同行朋友把行李提过来并在客运大楼打印登机牌。<br>此时我们航班的登机口仍未确定，并且航班延误到了10点20分起飞，就在这时我看到了<a href="http://www.bilibili.com/video/av63487681?share_medium=android&amp;share_source=qq&amp;bbid=RSZDJUYnFXFJcBUnWydbYlpiW24PPAw5DjoNinfoc&amp;ts=1565702723188" target="_blank" rel="noopener">一则新闻</a>，视频中老外被围堵的地方，不就是我们前往霓虹时吃麦当劳的地方吗？！<br>我感到了香港机场的危险，还好我们此时在客运大楼海关内部最深处的候机厅，刚刚去吃饭的时候我发现有许多警察在海关待机，至少我们现在是比较安全的。<br>随后我们的航班取消了。<br><img src="/HongKongAirline/14.jpg" alt><br>有许多人围堵了香港航空的柜台，工作人员表示他们现在也不清楚情况，5分钟前才知道取消的消息，他们正在打电话确认情况。<br>有几位游客不耐烦地怒吼：“我们已经等了几个小时了，要取消为什么不早点说？”为他们的愚蠢我感到非常地遗憾。然而有明白事理的群众指责这些人耐心点，也有更惨的告诉他们自己已经等了两三天了。<br>港航工作人员随后告知我们这个公示屏幕显示的是假消息，是为了展示给示威群众看好让他们停止闹事，其实航班并没有取消（但仍有可能会取消）。<br>不久，我们的航班登机口确定了，于是航班取消的可能性大大降低了。<br><img src="/HongKongAirline/15.jpg" alt><br>大约十点钟的时候，我们发现飞机已经到达登机口，正在加油。<br><img src="/HongKongAirline/16.jpg" alt><br>不久航班开始值机，我们大约于10点45分起飞。<br><img src="/HongKongAirline/17.jpg" alt><br>并大约于0点30分到达重庆江北机场，过海关，结束了我的旅程。</p><p><strong>后记</strong><br>这篇文章我本来不准备发布的，怕影响之后航班的乘客。<br>然而目前香港机场已经取得临时禁制权，只有持有24小时内登机牌以及相关证件的乘客才能进入客运大楼，所有航班已恢复正常，于是我决定把这篇文章发布出来。<br>香港机场，香港航空，你们很棒，加油！<br>对于隔壁的国泰航空，我只想说，No zuo No die。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，香港近期发生了严重的骚乱，然而不巧的是，本人去日本旅行刚好往返均需要在香港转机，因此笔者目睹了香港机场的状况并持续关注，现在将我的经历与评论记录在此。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://blog.bill.moe/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://blog.bill.moe/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>去日本啦</title>
    <link href="https://blog.bill.moe/jp-journey/"/>
    <id>https://blog.bill.moe/jp-journey/</id>
    <published>2019-08-03T15:07:31.000Z</published>
    <updated>2019-08-14T06:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>标题翻译：将会长期咕咕咕。<br><a id="more"></a></p><style type="text/css">    /*给网页添加 黑白滤镜*/    html{        /*兼容FF*/        filter: url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'grayscale\'><feColorMatrix type=\'matrix\' values=\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\'/></filter></svg>#grayscale");        /*兼容IE内核*/        filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);        /*兼容其它，谷歌之类的*/        -webkit-filter: grayscale(1);    } </style><div class="note error">            <p>愿逝者安息。<br><img src="/img/death.jpeg" alt></p>          </div><p>本人计划于 2019/08/05 ~ 2019/08/13 在日本国度过愉快的一周。<br>计划前往参观环球影城，富士山，给京阿尼献花，国立博物馆，秋叶原，参加C96。</p><p>作为咕咕咕的补偿，发一个福利吧。<br>成功猜中我的航班，就可以获得神秘礼品，期限为 2019/08/15 之前。<br>猜中部分即可获三等奖，猜中单程获二等奖，猜中往返获一等奖。<br>奖品我会在日本入手，具体保密。</p><p>那么诸位告辞。</p><p>update：回来啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标题翻译：将会长期咕咕咕。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://blog.bill.moe/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://blog.bill.moe/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>圆方树学习笔记</title>
    <link href="https://blog.bill.moe/cir-squ-tree-notes/"/>
    <id>https://blog.bill.moe/cir-squ-tree-notes/</id>
    <published>2019-07-15T00:40:40.000Z</published>
    <updated>2020-07-12T13:40:37.665Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>补坑防忘。</p><a id="more"></a><h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><p>见多年前制作的<a href="/cir-squ-tree-notes/圆方树—仙人掌数据结构.pptx">ppt</a></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><strong>注意！！！以下代码均未处理二元环！！！</strong></p><p>2020/3/15更新：使用C++11压行</p><h3 id="不带权仙人掌"><a href="#不带权仙人掌" class="headerlink" title="不带权仙人掌"></a>不带权仙人掌</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">St</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line">St(<span class="keyword">int</span> x=<span class="number">0</span>,<span class="keyword">int</span> y=<span class="number">0</span>):u(x),v(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn],tree[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;St&gt;S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,step=<span class="number">0</span>,Lowlink[maxn],Dfn[maxn],BCC=<span class="number">0</span>,New,Square[maxn],Belong[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;edges[x].push_back(y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;tree[x].push_back(y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">//构建圆方树</span></span><br><span class="line">Lowlink[Now]=Dfn[Now]=++step;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">if</span>(!Dfn[Next]) &#123;</span><br><span class="line">S.push(St(Now,Next));</span><br><span class="line">Tarjan(Next,Now);</span><br><span class="line">Lowlink[Now]=min(Lowlink[Now],Lowlink[Next]);</span><br><span class="line"><span class="keyword">if</span>(Dfn[Now]&lt;Lowlink[Next])AddEdge2(Now,Next),S.pop();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Dfn[Now]==Lowlink[Next]) &#123; <span class="comment">//构成点双连通分量</span></span><br><span class="line">BCC++;</span><br><span class="line">AddEdge2(Now,++New);</span><br><span class="line">Square[New]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!S.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u=S.top().u;S.pop();</span><br><span class="line"><span class="keyword">if</span>(u==Now)<span class="keyword">break</span>;</span><br><span class="line">Belong[u]=BCC;</span><br><span class="line">AddEdge2(New,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(Next!=fa&amp;&amp;Lowlink[Now]&gt;Dfn[Next]) &#123;</span><br><span class="line">Lowlink[Now]=Dfn[Next];</span><br><span class="line">S.push(St(Now,Next));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带权仙人掌"><a href="#带权仙人掌" class="headerlink" title="带权仙人掌"></a>带权仙人掌</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,dist;</span><br><span class="line">Edge(<span class="keyword">int</span> x=<span class="number">0</span>,<span class="keyword">int</span> y=<span class="number">0</span>,<span class="keyword">int</span> v=<span class="number">0</span>):from(x),to(y),dist(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">St</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,dist;</span><br><span class="line">St(<span class="keyword">int</span> x=<span class="number">0</span>,<span class="keyword">int</span> y=<span class="number">0</span>,<span class="keyword">int</span> va=<span class="number">0</span>):u(x),v(y),dist(va) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges[maxn],tree[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Circle[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;St&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> step=<span class="number">0</span>,Lowlink[maxn],Dfn[maxn],BCC=<span class="number">0</span>,New,Length[maxn],f[maxn],Belong[maxn],vst[maxn],Square[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span> </span>&#123;edges[x].push_back(Edge(x,y,v));&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span> </span>&#123;tree[x].push_back(Edge(x,y,v));&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> Now,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">step++;</span><br><span class="line">Lowlink[Now]=Dfn[Now]=step;</span><br><span class="line"><span class="keyword">for</span>(Edge &amp;e:edges[Now]) &#123;</span><br><span class="line"><span class="keyword">int</span> Next=e.to;</span><br><span class="line"><span class="keyword">if</span>(!Dfn[Next]) &#123;</span><br><span class="line">S.push(St(Now,Next,e.dist));</span><br><span class="line">Tarjan(Next,Now);</span><br><span class="line">Lowlink[Now]=min(Lowlink[Now],Lowlink[Next]);</span><br><span class="line"><span class="keyword">if</span>(Dfn[Now]&lt;Lowlink[Next])AddEdge2(Now,Next,e.dist),S.pop();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Dfn[Now]==Lowlink[Next]) &#123; <span class="comment">//构成点双连通分量</span></span><br><span class="line">BCC++;</span><br><span class="line">AddEdge2(Now,++New,<span class="number">0</span>);</span><br><span class="line">Square[New]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!S.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u=S.top().u,v=S.top().v,dist=S.top().dist;S.pop();</span><br><span class="line">Length[BCC]+=dist;</span><br><span class="line">f[u]=f[v]+dist;</span><br><span class="line"><span class="keyword">if</span>(u!=Now)Belong[u]=BCC,Circle[New].push_back(u);</span><br><span class="line"><span class="keyword">if</span>(u==Now&amp;&amp;v==Next)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Next:Circle[New])AddEdge2(New,Next,min(<span class="built_in">abs</span>(f[Next]-f[Now]),Length[BCC]-<span class="built_in">abs</span>(f[Next]-f[Now])));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(Next!=fa&amp;&amp;Lowlink[Now]&gt;Dfn[Next]) &#123;</span><br><span class="line">Lowlink[Now]=Dfn[Next];</span><br><span class="line">S.push(St(Now,Next,e.dist));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;补坑防忘。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="https://blog.bill.moe/categories/OI/"/>
    
    
      <category term="学习笔记" scheme="https://blog.bill.moe/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="圆方树" scheme="https://blog.bill.moe/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"/>
    
      <category term="仙人掌" scheme="https://blog.bill.moe/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C/"/>
    
  </entry>
  
</feed>
